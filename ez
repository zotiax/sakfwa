setfpscap(3294584223)




wait(3)


getfenv().LPH_NO_VIRTUALIZE = function(...) return ... end;

local gamerawmetatable = getrawmetatable(game)
setreadonly(gamerawmetatable, false)

old__namecall1 = gamerawmetatable.__namecall;gamerawmetatable.__namecall = newcclosure(function(self, ...)
    local args = {...}
    if tostring(args[1]) == "TeleportDetect" then
        return
    elseif tostring(args[1]) == "CHECKER_1" then
        return
    elseif tostring(args[1]) == "CHECKER" then
        return
    elseif tostring(args[1]) == "GUI_CHECK" then
        return
    elseif tostring(args[1]) == "OneMoreTime" then
        return
    elseif tostring(args[1]) == "checkingSPEED" then
        return
    elseif tostring(args[1]) == "BANREMOTE" then
        return
    elseif tostring(args[1]) == "PERMAIDBAN" then
        return
    elseif tostring(args[1]) == "KICKREMOTE" then
        return
    elseif tostring(args[1]) == "BR_KICKPC" then
        return
    elseif tostring(args[1]) == "BR_KICKMOBILE" then
        return
    end
    return old__namecall1(self, ...)
end)


-- hookfunction security
local exe_name, exe_version = identifyexecutor()
local function home999() end
local function home888() end

if exe_name ~= "Wave Windows" then
    hookfunction(home888, home999)
    if isfunctionhooked(home888) == false then
        game.Players.LocalPlayer:Destroy()
        return LPH_CRASH()
    end
end 

local function check_env(env)
    for _, func in env do
        if type(func) ~= "function" then
            continue
        end

        local functionhook = isfunctionhooked(func)

        if functionhook then
            game.Players.LocalPlayer:Destroy()
            return LPH_CRASH()
        end
    end
end

check_env( getgenv() )
check_env( getrenv() )
--

local Lua_Fetch_Connections = getconnections
local Lua_Fetch_Upvalues = getupvalues
local Lua_Hook = hookfunction 
local Lua_Hook_Method = hookmetamethod
local Lua_Unhook = restorefunction
local Lua_Replace_Function = replaceclosure
local Lua_Set_Upvalue = setupvalue
local Lua_Clone_Function = clonefunction

local Game_RunService = game:GetService("RunService")
local Game_LogService = game:GetService("LogService")
local Game_LogService_MessageOut = Game_LogService.MessageOut

local String_Lower = string.lower
local Table_Find = table.find
local Get_Type = type

local Current_Connections = {};
local Hooked_Connections = {};

local function Test_Table(Table, Return_Type)
for TABLE_INDEX, TABLE_VALUE in Table do
    if type(TABLE_VALUE) == String_Lower(Return_Type) then
        return TABLE_VALUE, TABLE_INDEX
    end

    continue
end
end

local function Print_Table(Table)
table.foreach(Table, print)
end

if getgenv().DEBUG then
print("[auth.injected.live] Waiting...")
end

local good_check = 0

function auth_heart()
-- local avalible = pcall(function() return loadstring(game:HttpGet("https://auth.injected.live/" .. directory))() end)

-- if (not avalible or not game:HttpGet("https://auth.injected.live/" .. directory)) and good_check <= 0 then
--     print("error", avalible, game:HttpGet("https://auth.injected.live/" .. directory))
--     game.Players.LocalPlayer:Destroy()
--     return LPH_CRASH()
-- end

return true , true
end

function Lua_Common_Intercept(old, ...)
print(...)
return old(...)
end

function XVNP_L(CONNECTION)
local s, e = pcall(function()
    local OPENAC_TABLE = Lua_Fetch_Upvalues(CONNECTION.Function)[9]
    local OPENAC_FUNCTION = OPENAC_TABLE[1]
    local IGNORED_INDEX = {3, 12, 1, 11, 15, 8, 20, 18, 22}

    --[[
        3(Getfenv), 1(create thread), 12(Some thread function errors btw), 11( buffer (BANS YOU) ), 8(BXOR), 14(WRAP), 15(YIELD), 22(JUNK), 20(Setfenv), 18(Idk for now)
    ]]


    Lua_Set_Upvalue(OPENAC_FUNCTION, 14, function(...)
        return function(...)
            local args = {...}

            if type(args[1]) == "table" and args[1][1] then
                pcall(function()
                    if type(args[1][1]) == "userdata" then
                        args[1][1]:Disconnect()
                        args[1][2]:Disconnect()
                        args[1][3]:Disconnect()
                        args[1][4]:Disconnect()
                        --warn("[XVNP] DISCONNECTING CURRENT FUNCTIONS")
                    end

                    --Print_Table(args[1])
                end)
            end 
        end
    end)

    Lua_Set_Upvalue(OPENAC_FUNCTION, 1, function(...)
        task.wait(200)
    end)

    hookfunction(OPENAC_FUNCTION, function(...)
        --warn("[XVNP DEBUG]", ...)
        return {}
    end)
end)
end

local XVNP_LASTUPDATE = 0
local XVNP_UPDATEINTERVAL = 5

local XVNP_CONNECTIONSNIFFER;

XVNP_CONNECTIONSNIFFER = Game_RunService.RenderStepped:Connect(function()
if #Lua_Fetch_Connections(Game_LogService_MessageOut) >= 2 then
    --print("[XVNP] !Emulator overflow!")
    XVNP_CONNECTIONSNIFFER:Disconnect()
end

if tick() - XVNP_LASTUPDATE >= XVNP_UPDATEINTERVAL then
    XVNP_LASTUPDATE = tick() 

    local OpenAc_Connections = Lua_Fetch_Connections(Game_LogService_MessageOut)

    for _, CONNECTION in OpenAc_Connections do
        if not table.find(Current_Connections, CONNECTION) then
            table.insert(Current_Connections, CONNECTION)
            table.insert(Hooked_Connections, CONNECTION)

            XVNP_L(CONNECTION)
            
        end
    end
end
end)

local last_beat = 0
Game_RunService.RenderStepped:Connect(function()
if last_beat + 1 < tick() then
    last_beat = tick() + 1 

    local what, are = auth_heart()

    if not are or not what then
        if good_check <= 0 then
            game.Players.LocalPlayer:Destroy()
            return LPH_CRASH()
        else
            good_check -=1
        end
    else
        good_check += 1
    end

end
end)

if getgenv().DEBUG then
print("[auth.injected.live] Started Emulation Thread")
end



local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/i77lhm/vaderpaste/refs/heads/main/library.lua"))() 
local flags = library.flags -- access flags from here.

local window = library:window({
    name = "Oracle.net", 
    size = UDim2.fromOffset(600, 700) 
}) 

local rage_tab = window:tab({name = "rage"})
local aa_tab = window:tab({name = "anti aim"})
local legit = window:tab({name = "legit"})
local visuals = window:tab({name = "visuals"})
local local_tab = window:tab({name = "local"})


-- Local Visuals Section
local local_visuals = local_tab:section({name = "Local Visuals", side = "left"})
local crosshair_section = local_tab:section({name = "Crosshair", side = "right"})

-- Silent Aim Section
local SilentAimSection = legit:section({name = "Silent Aim", side = "left"})

-- Silent Aim Configuration
local SilentAim = {
    Enabled = false,
    SelectedParts = {"Head"},
    UseClosestPart = false,
    FOV = {
        Radius = 100,
        Visible = false,
        Filled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 0.5,
        OutlineColor = Color3.fromRGB(0, 0, 0),
        OutlineTransparency = 0
    },
    HitChance = 100,
    WallCheck = false,
    IgnoreKnocked = false,
    TargetVisualization = {
        Enabled = false,
        Type = "Highlight", -- "Highlight", "Box", "Arrow"
        Color = Color3.fromRGB(255, 0, 0),
        Transparency = 0.5,
        PulseEffect = false,
        PulseSpeed = 1
    },
    DaHoodParts = { -- All possible parts for Da Hood
        "Head",
        "UpperTorso",
        "LowerTorso",
        "HumanoidRootPart",
        "RightUpperArm",
        "LeftUpperArm",
        "RightLowerArm",
        "LeftLowerArm",
        "RightHand",
        "LeftHand",
        "RightUpperLeg",
        "LeftUpperLeg",
        "RightLowerLeg",
        "LeftLowerLeg",
        "RightFoot",
        "LeftFoot"
    }
}

-- FOV Circle Drawing
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.NumSides = 100
FOVCircle.Radius = SilentAim.FOV.Radius
FOVCircle.Filled = SilentAim.FOV.Filled
FOVCircle.Visible = false
FOVCircle.Color = SilentAim.FOV.Color
FOVCircle.Transparency = SilentAim.FOV.Transparency

-- Target Visualization Objects
local TargetHighlight = Instance.new("Highlight")
TargetHighlight.FillColor = SilentAim.TargetVisualization.Color
TargetHighlight.OutlineColor = SilentAim.TargetVisualization.Color
TargetHighlight.FillTransparency = SilentAim.TargetVisualization.Transparency
TargetHighlight.OutlineTransparency = 0.2
TargetHighlight.Enabled = false
TargetHighlight.Parent = game.CoreGui

-- Target Box Drawing
local TargetBox = {
    Top = Drawing.new("Line"),
    Bottom = Drawing.new("Line"),
    Left = Drawing.new("Line"),
    Right = Drawing.new("Line"),
    TopLeft = Drawing.new("Line"),
    TopRight = Drawing.new("Line"),
    BottomLeft = Drawing.new("Line"),
    BottomRight = Drawing.new("Line")
}

-- Configure box lines
for _, line in pairs(TargetBox) do
    line.Visible = false
    line.Color = SilentAim.TargetVisualization.Color
    line.Thickness = 1.5
    line.Transparency = 1 - SilentAim.TargetVisualization.Transparency
end

-- Target Arrow Drawing
local TargetArrow = Drawing.new("Triangle")
TargetArrow.Visible = false
TargetArrow.Color = SilentAim.TargetVisualization.Color
TargetArrow.Thickness = 1.5
TargetArrow.Transparency = 1 - SilentAim.TargetVisualization.Transparency
TargetArrow.Filled = true

-- Silent Aim Toggles and Settings
SilentAimSection:toggle({name = "Enable Silent Aim", flag = "silent_aim_enabled", callback = function(value)
    SilentAim.Enabled = value
end})

-- Hit Part Dropdown
SilentAimSection:dropdown({
    name = "Hit Part", 
    flag = "silent_aim_hitpart", 
    items = {"Head", "HumanoidRootPart", "LowerTorso"},
    default = "Head", 
    callback = function(value)
        SilentAim.SelectedParts = {value}
    end
})

-- Closest Part Toggle
SilentAimSection:toggle({name = "Use Closest Part", flag = "silent_aim_closest_part", callback = function(value)
    SilentAim.UseClosestPart = value
end})

-- FOV Settings
SilentAimSection:toggle({name = "Show FOV Circle", flag = "silent_aim_fov_visible", callback = function(value)
    SilentAim.FOV.Visible = value
    FOVCircle.Visible = value
end})

SilentAimSection:toggle({name = "Fill FOV Circle", flag = "silent_aim_fov_filled", callback = function(value)
    SilentAim.FOV.Filled = value
    FOVCircle.Filled = value
end})

SilentAimSection:slider({name = "FOV Radius", flag = "silent_aim_fov", min = 10, max = 500, value = 100, callback = function(value)
    SilentAim.FOV.Radius = value
    FOVCircle.Radius = value
end})

SilentAimSection:slider({name = "FOV Transparency", flag = "silent_aim_fov_transparency", min = 0, max = 100, value = 50, callback = function(value)
    SilentAim.FOV.Transparency = 1 - (value / 100)
    FOVCircle.Transparency = 1 - (value / 100)
end})

SilentAimSection:colorpicker({name = "FOV Color", flag = "silent_aim_fov_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    SilentAim.FOV.Color = color
    FOVCircle.Color = color
end})

SilentAimSection:colorpicker({name = "FOV Outline Color", flag = "silent_aim_fov_outline_color", default = Color3.fromRGB(0, 0, 0), callback = function(color)
    SilentAim.FOV.OutlineColor = color
end})

-- Target Settings
SilentAimSection:toggle({name = "Wall Check", flag = "silent_aim_wall_check", callback = function(value)
    SilentAim.WallCheck = value
end})

SilentAimSection:toggle({name = "Ignore Knocked Players", flag = "silent_aim_ignore_knocked", callback = function(value)
    SilentAim.IgnoreKnocked = value
end})

SilentAimSection:slider({name = "Hit Chance", flag = "silent_aim_hitchance", min = 0, max = 100, value = 100, callback = function(value)
    SilentAim.HitChance = value
end})

-- Target Visualization Settings
SilentAimSection:toggle({name = "Target Visualization", flag = "silent_aim_target_visualization", callback = function(value)
    SilentAim.TargetVisualization.Enabled = value
end})

SilentAimSection:dropdown({
    name = "Visualization Type", 
    flag = "silent_aim_visualization_type", 
    items = {"Highlight", "Box", "Arrow"},
    default = "Highlight", 
    callback = function(value)
        SilentAim.TargetVisualization.Type = value
    end
})

SilentAimSection:colorpicker({name = "Target Color", flag = "silent_aim_target_color", default = Color3.fromRGB(255, 0, 0), callback = function(color)
    SilentAim.TargetVisualization.Color = color
    TargetHighlight.FillColor = color
    TargetHighlight.OutlineColor = color
    
    for _, line in pairs(TargetBox) do
        line.Color = color
    end
    
    TargetArrow.Color = color
end})

SilentAimSection:toggle({name = "Pulse Effect", flag = "silent_aim_pulse_effect", callback = function(value)
    SilentAim.TargetVisualization.PulseEffect = value
end})

SilentAimSection:slider({name = "Pulse Speed", flag = "silent_aim_pulse_speed", min = 0.1, max = 5, value = 1, callback = function(value)
    SilentAim.TargetVisualization.PulseSpeed = value
end})

-- Implement Silent Aim functionality
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")

-- Function to check if a player is knocked (Da Hood specific)
local function IsPlayerKnocked(character)
    if not SilentAim.IgnoreKnocked then
        return false
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- Da Hood specific knocked detection
        if humanoid.PlatformStand then
            return true
        end
        
        -- Check for Da Hood specific knocked state
        if humanoid:GetState() == Enum.HumanoidStateType.Physics then
            return true
        end
        
        -- Check for Da Hood specific knocked animations
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if animator then
            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                local name = string.lower(track.Name)
                if name:find("knocked") or name:find("down") or name:find("ragdoll") then
                    return true
                end
            end
        end
        
        -- Check for Da Hood specific knocked values
        if character:FindFirstChild("Knocked") or character:FindFirstChild("BodyEffects") and character.BodyEffects:FindFirstChild("K.O") and character.BodyEffects["K.O"].Value then
            return true
        end
    end
    
    return false
end

-- Function to check if a part is visible (not behind a wall)
local function IsPartVisible(Part)
    if not SilentAim.WallCheck then
        return true
    end
    
    local Origin = Camera.CFrame.Position
    local Direction = (Part.Position - Origin).Unit
    local RaycastParams = RaycastParams.new()
    RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    RaycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Part.Parent}
    
    local RaycastResult = workspace:Raycast(Origin, Direction * (Part.Position - Origin).Magnitude, RaycastParams)
    return RaycastResult == nil
end

-- Function to get the closest body part to the mouse
local function GetClosestBodyPart(target)
    local mousePosition = UserInputService:GetMouseLocation()
    local closestPart = nil
    local closestDistance = math.huge
    
    for _, partName in pairs(SilentAim.DaHoodParts) do
        local part = target.Character:FindFirstChild(partName)
        if part then
            local screenPosition, onScreen = Camera:WorldToScreenPoint(part.Position)
            if onScreen and IsPartVisible(part) then
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPart = part
                end
            end
        end
    end
    
    return closestPart
end

-- Function to update target visualization
local function UpdateTargetVisualization(target)
    -- Clear previous visualization
    TargetHighlight.Enabled = false
    TargetHighlight.Parent = game.CoreGui
    
    for _, line in pairs(TargetBox) do
        line.Visible = false
    end
    
    TargetArrow.Visible = false
    
    -- If no target or visualization disabled, return
    if not target or not SilentAim.TargetVisualization.Enabled then
        return
    end
    
    local character = target.Parent
    if not character then return end
    
    -- Apply visualization based on selected type
    if SilentAim.TargetVisualization.Type == "Highlight" then
        TargetHighlight.Adornee = character
        TargetHighlight.Enabled = true
        
        -- Apply pulse effect if enabled
        if SilentAim.TargetVisualization.PulseEffect then
            local pulse = math.abs(math.sin(tick() * SilentAim.TargetVisualization.PulseSpeed))
            TargetHighlight.FillTransparency = 0.7 - (pulse * 0.5)
        else
            TargetHighlight.FillTransparency = SilentAim.TargetVisualization.Transparency
        end
    
    elseif SilentAim.TargetVisualization.Type == "Box" then
        -- Get character bounds
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local size = Vector3.new(4, 5, 1)
        local cf = hrp.CFrame
        
        -- Calculate corners of the box
        local TLF = Camera:WorldToViewportPoint((cf * CFrame.new(-size.X/2, size.Y/2, 0)).Position)
        local TRF = Camera:WorldToViewportPoint((cf * CFrame.new(size.X/2, size.Y/2, 0)).Position)
        local BLF = Camera:WorldToViewportPoint((cf * CFrame.new(-size.X/2, -size.Y/2, 0)).Position)
        local BRF = Camera:WorldToViewportPoint((cf * CFrame.new(size.X/2, -size.Y/2, 0)).Position)
        
        -- Apply pulse effect if enabled
        local transparency = SilentAim.TargetVisualization.Transparency
        if SilentAim.TargetVisualization.PulseEffect then
            local pulse = math.abs(math.sin(tick() * SilentAim.TargetVisualization.PulseSpeed))
            transparency = transparency - (pulse * 0.5)
            transparency = math.clamp(transparency, 0, 1)
        end
        
        -- Update box lines
        TargetBox.Top.From = Vector2.new(TLF.X, TLF.Y)
        TargetBox.Top.To = Vector2.new(TRF.X, TRF.Y)
        TargetBox.Top.Transparency = 1 - transparency
        TargetBox.Top.Visible = true
        
        TargetBox.Bottom.From = Vector2.new(BLF.X, BLF.Y)
        TargetBox.Bottom.To = Vector2.new(BRF.X, BRF.Y)
        TargetBox.Bottom.Transparency = 1 - transparency
        TargetBox.Bottom.Visible = true
        
        TargetBox.Left.From = Vector2.new(TLF.X, TLF.Y)
        TargetBox.Left.To = Vector2.new(BLF.X, BLF.Y)
        TargetBox.Left.Transparency = 1 - transparency
        TargetBox.Left.Visible = true
        
        TargetBox.Right.From = Vector2.new(TRF.X, TRF.Y)
        TargetBox.Right.To = Vector2.new(BRF.X, BRF.Y)
        TargetBox.Right.Transparency = 1 - transparency
        TargetBox.Right.Visible = true
        
    elseif SilentAim.TargetVisualization.Type == "Arrow" then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        -- Calculate arrow position (pointing to target)
        local targetPos = Camera:WorldToViewportPoint(hrp.Position)
        if targetPos.Z < 0 then return end -- Target behind camera
        
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local direction = (Vector2.new(targetPos.X, targetPos.Y) - screenCenter).Unit
        local arrowSize = 20
        
        -- Apply pulse effect if enabled
        local transparency = SilentAim.TargetVisualization.Transparency
        if SilentAim.TargetVisualization.PulseEffect then
            local pulse = math.abs(math.sin(tick() * SilentAim.TargetVisualization.PulseSpeed))
            transparency = transparency - (pulse * 0.5)
            transparency = math.clamp(transparency, 0, 1)
        end
        
        -- Calculate arrow points
        local arrowTip = screenCenter + direction * 100
        local perpendicular = Vector2.new(-direction.Y, direction.X) * arrowSize
        
        TargetArrow.PointA = arrowTip
        TargetArrow.PointB = arrowTip - direction * arrowSize + perpendicular
        TargetArrow.PointC = arrowTip - direction * arrowSize - perpendicular
        TargetArrow.Transparency = 1 - transparency
        TargetArrow.Visible = true
    end
end

-- Function to get the closest player based on mouse position and selected parts
local function GetClosestPlayer()
    -- Hit chance check
    if SilentAim.HitChance < 100 and math.random(1, 100) > SilentAim.HitChance then
        return nil
    end
    
    -- Use mouse position for targeting
    local MousePosition = UserInputService:GetMouseLocation()
    local FOVPosition = MousePosition -- FOV follows mouse
    
    -- Store all valid parts with their distances
    local AllValidParts = {}
    
    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character then
            local Character = Player.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")
            
            if Humanoid and Humanoid.Health > 0 and not IsPlayerKnocked(Character) then
                if SilentAim.UseClosestPart then
                    -- Get closest body part to mouse
                    local closestPart = GetClosestBodyPart(Player)
                    if closestPart then
                        local ScreenPosition, Visible = Camera:WorldToScreenPoint(closestPart.Position)
                        if Visible and IsPartVisible(closestPart) then
                            -- Check if part is within FOV
                            local FOVDistance = (FOVPosition - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
                            if FOVDistance <= SilentAim.FOV.Radius then
                                -- Store this valid part
                                table.insert(AllValidParts, {
                                    Player = Player,
                                    Part = closestPart
                                })
                            end
                        end
                    end
                else
                    -- Check all selected parts for this player
                    for _, PartName in ipairs(SilentAim.SelectedParts) do
                        local HitPart = Character:FindFirstChild(PartName)
                        if HitPart then
                            local ScreenPosition, Visible = Camera:WorldToScreenPoint(HitPart.Position)
                            if Visible and IsPartVisible(HitPart) then
                                -- Check if part is within FOV
                                local FOVDistance = (FOVPosition - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
                                if FOVDistance <= SilentAim.FOV.Radius then
                                    -- Store this valid part
                                    table.insert(AllValidParts, {
                                        Player = Player,
                                        Part = HitPart
                                    })
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- If no valid parts found, return nil
    if #AllValidParts == 0 then
        return nil
    end
    
    -- Return a random part from the valid parts
    return AllValidParts[math.random(1, #AllValidParts)].Part
end

-- Update FOV Circle position and target visualization
game:GetService("RunService").RenderStepped:Connect(function()
    -- Update Silent Aim FOV Circle
    if FOVCircle ~= nil then
        FOVCircle.Position = UserInputService:GetMouseLocation()
        FOVCircle.Visible = SilentAim.FOV.Visible and SilentAim.Enabled
    end
    
    -- Update Silent Aim target visualization
    if SilentAim.Enabled and SilentAim.TargetVisualization.Enabled then
        local currentTarget = GetClosestPlayer()
        UpdateTargetVisualization(currentTarget)
    else
        UpdateTargetVisualization(nil)
    end
end)

-- Hook mouse methods for silent aim
local success, grm = pcall(getrawmetatable, game)
if success and grm and grm.__index and setreadonly then
    local index = grm.__index
    setreadonly(grm, false)
    
    grm.__index = function(self, Index)
        if not checkcaller() and self == Mouse then
            if Index == "Hit" or Index == "Target" then
                -- Only use Silent Aim for mouse redirection
                if SilentAim.Enabled then
                    local TargetPart = GetClosestPlayer()
                    if TargetPart then
                        return Index == "Hit" and CFrame.new(TargetPart.Position) or TargetPart.Parent
                    end
                end
            end
        end
        return index(self, Index)
    end
    
    setreadonly(grm, true)
end

-- Settings table to store all configuration values
local settings = {
    player = {
        material = Enum.Material.Plastic,
        color = Color3.fromRGB(255, 255, 255),
        transparency = 0,
        originalData = {}
    },
    highlight = {
        enabled = false,
        fillColor = Color3.fromRGB(255, 255, 255),
        outlineColor = Color3.fromRGB(0, 170, 255),
        instance = nil
    },
    footsteps = {
        enabled = false,
        mode = "In", -- "In" or "Out"
        size = 1,
        color = Color3.fromRGB(0, 170, 255),
        circles = {},
        timers = {},
        lifetime = 2,
        lastTime = 0,
        interval = 0.3
    },
    crosshair = {
        enabled = false,
        size = 10,
        thickness = 1.5,
        outlineThickness = 3,
        color = Color3.fromRGB(255, 255, 255),
        outlineColor = Color3.fromRGB(0, 0, 0),
        sineSpeed = 1,
        sineStrength = 0.3,
        smoothness = 0.2,
        spinSpeed = 0,
        method = "Center",
        followSmoothness = 0.2,
        lastMousePosition = Vector2.new(),
        gapSize = 2,
        gapSineSpeed = 0,
        gapSineStrength = 0.5,
        angle = 0,
        lines = {},
        outlines = {},
        centerPanel = {
            enabled = false,
            text = "Oracle.net",
            color = Color3.fromRGB(255, 255, 255),
            outlineColor = Color3.fromRGB(0, 0, 0),
            transparency = 1,
            textSize = 16,
            offset = Vector2.new(0, 15),
            instance = nil
        }
    }
}

-- Create crosshair drawing objects
settings.crosshair.lines = {
    top = Drawing.new("Line"),
    bottom = Drawing.new("Line"),
    left = Drawing.new("Line"),
    right = Drawing.new("Line")
}

for _, line in pairs(settings.crosshair.lines) do
    line.Visible = false
    line.Thickness = settings.crosshair.thickness
    line.Color = settings.crosshair.color
    line.Transparency = 1
    line.ZIndex = 999
end

settings.crosshair.outlines = {
    top = Drawing.new("Line"),
    bottom = Drawing.new("Line"),
    left = Drawing.new("Line"),
    right = Drawing.new("Line")
}

for _, line in pairs(settings.crosshair.outlines) do
    line.Visible = false
    line.Thickness = settings.crosshair.outlineThickness
    line.Color = settings.crosshair.outlineColor
    line.Transparency = 1
    line.ZIndex = 998
end

-- Create center panel text
settings.crosshair.centerPanel.instance = Drawing.new("Text")
settings.crosshair.centerPanel.instance.Visible = false
settings.crosshair.centerPanel.instance.Text = settings.crosshair.centerPanel.text
settings.crosshair.centerPanel.instance.Size = settings.crosshair.centerPanel.textSize
settings.crosshair.centerPanel.instance.Color = settings.crosshair.centerPanel.color
settings.crosshair.centerPanel.instance.Center = true
settings.crosshair.centerPanel.instance.Outline = true
settings.crosshair.centerPanel.instance.OutlineColor = settings.crosshair.centerPanel.outlineColor
settings.crosshair.centerPanel.instance.Transparency = settings.crosshair.centerPanel.transparency
settings.crosshair.centerPanel.instance.ZIndex = 999

-- Function to save original character properties
local function saveOriginalPlayerData()
    settings.player.originalData = {}
    if game.Players.LocalPlayer.Character then
        for _, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                settings.player.originalData[part] = {
                    Material = part.Material,
                    Color = part.Color,
                    Transparency = part.Transparency
                }
            end
        end
    end
end

-- Function to apply custom material to local player
local function applyPlayerMaterial()
    if game.Players.LocalPlayer.Character then
        for _, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.Material = settings.player.material
                part.Color = settings.player.color
                part.Transparency = settings.player.transparency
            end
        end
    end
end

-- Function to update player color and transparency without toggling
local function updatePlayerVisuals()
    if game.Players.LocalPlayer.Character and flags["Player_Material"] then
        for _, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.Color = settings.player.color
                part.Transparency = settings.player.transparency
            end
        end
    end
end

-- Function to reset player character to original state
local function resetPlayerVisuals()
    if game.Players.LocalPlayer.Character then
        for part, data in pairs(settings.player.originalData) do
            if part and part.Parent then
                part.Material = data.Material
                part.Color = data.Color
                part.Transparency = data.Transparency
            end
        end
    end
end

-- Function to apply highlight to player
local function updatePlayerHighlight()
    -- Remove existing highlight
    if settings.highlight.instance and settings.highlight.instance.Parent then
        settings.highlight.instance:Destroy()
        settings.highlight.instance = nil
    end

    if settings.highlight.enabled and game.Players.LocalPlayer.Character then
        settings.highlight.instance = Instance.new("Highlight")
        settings.highlight.instance.Name = "PlayerHighlight"
        settings.highlight.instance.FillColor = settings.highlight.fillColor
        settings.highlight.instance.OutlineColor = settings.highlight.outlineColor
        settings.highlight.instance.FillTransparency = 0.5
        settings.highlight.instance.OutlineTransparency = 0
        settings.highlight.instance.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        settings.highlight.instance.Parent = game.Players.LocalPlayer.Character
    end
end

-- Function to create a footstep circle
local function createFootstepCircle(position)
    local circle = Instance.new("Part")
    circle.Shape = Enum.PartType.Cylinder
    circle.Size = Vector3.new(0.05, settings.footsteps.size, settings.footsteps.size)
    circle.Anchored = true
    circle.CanCollide = false
    circle.Material = Enum.Material.Neon
    circle.Color = settings.footsteps.color
    circle.Transparency = 0.3

    -- Rotate to make cylinder flat on the ground
    circle.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))

    circle.Parent = workspace

    -- Add to footstep circles table and record creation time
    table.insert(settings.footsteps.circles, circle)
    table.insert(settings.footsteps.timers, os.time())

    -- If mode is "Out", animate the circle growing
    if settings.footsteps.mode == "Out" then
        spawn(function()
            local startSize = settings.footsteps.size
            local endSize = startSize * 3
            local duration = settings.footsteps.lifetime
            local startTime = tick()
            
            while circle and circle.Parent do
                local elapsed = tick() - startTime
                local alpha = math.min(elapsed / duration, 1)
                
                if alpha >= 1 then break end
                
                local currentSize = startSize + (endSize - startSize) * alpha
                circle.Size = Vector3.new(0.05, currentSize, currentSize)
                circle.Transparency = 0.3 + (0.7 * alpha)
                
                wait(0.03)
            end
        end)
    elseif settings.footsteps.mode == "In" then
        spawn(function()
            local startSize = settings.footsteps.size * 3
            local endSize = settings.footsteps.size
            local duration = settings.footsteps.lifetime
            local startTime = tick()
            
            circle.Size = Vector3.new(0.05, startSize, startSize)
            
            while circle and circle.Parent do
                local elapsed = tick() - startTime
                local alpha = math.min(elapsed / duration, 1)
                
                if alpha >= 1 then break end
                
                local currentSize = startSize - ((startSize - endSize) * alpha)
                circle.Size = Vector3.new(0.05, currentSize, currentSize)
                circle.Transparency = 0.3 + (0.7 * alpha)
                
                wait(0.03)
            end
        end)
    end

    return circle
end

-- Function to update footstep circles
local function updateFootstepCircles()
    if not settings.footsteps.enabled or not game.Players.LocalPlayer.Character then return end

    local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    local rootPart = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end

    -- Only create footsteps when moving and on the ground
    if humanoid.MoveDirection.Magnitude > 0 and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
        local currentTime = tick()
        
        -- Create footsteps at intervals
        if currentTime - settings.footsteps.lastTime >= settings.footsteps.interval then
            settings.footsteps.lastTime = currentTime
            
            local footPosition = rootPart.Position - Vector3.new(0, 2.9, 0) -- Position at feet level
            createFootstepCircle(footPosition)
        end
    end

    -- Check for expired footstep circles
    local currentTime = os.time()
    while #settings.footsteps.circles > 0 and currentTime - settings.footsteps.timers[1] >= settings.footsteps.lifetime do
        local oldestCircle = table.remove(settings.footsteps.circles, 1)
        table.remove(settings.footsteps.timers, 1)
        
        if oldestCircle and oldestCircle.Parent then
            oldestCircle:Destroy()
        end
    end
end

-- Function to clear all footstep circles
local function clearFootstepCircles()
    for _, circle in ipairs(settings.footsteps.circles) do
        if circle and circle.Parent then
            circle:Destroy()
        end
    end
    settings.footsteps.circles = {}
    settings.footsteps.timers = {}
end

-- Function to rotate a point around a center
local function rotatePoint(x, y, centerX, centerY, angle)
    local radians = math.rad(angle)
    local newX = centerX + (x - centerX) * math.cos(radians) - (y - centerY) * math.sin(radians)
    local newY = centerY + (x - centerX) * math.sin(radians) + (y - centerY) * math.cos(radians)
    return newX, newY
end

-- Function to hide crosshair elements
local function hideCrosshair()
    for _, line in pairs(settings.crosshair.lines) do
        line.Visible = false
    end
    for _, line in pairs(settings.crosshair.outlines) do
        line.Visible = false
    end
    settings.crosshair.centerPanel.instance.Visible = false
end

-- Function to update crosshair
local function updateCrosshair()
    -- Hide all elements if disabled
    if not settings.crosshair.enabled then
        hideCrosshair()
        return
    end

    -- Get screen center or mouse position
    local viewportSize = game:GetService("Workspace").CurrentCamera.ViewportSize
    local crosshairCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    
    if settings.crosshair.method == "Follow Mouse" then
        local mousePos = game:GetService("UserInputService"):GetMouseLocation()
        if settings.crosshair.lastMousePosition.X == 0 and settings.crosshair.lastMousePosition.Y == 0 then
            settings.crosshair.lastMousePosition = mousePos
        end
        crosshairCenter = settings.crosshair.lastMousePosition:Lerp(mousePos, settings.crosshair.followSmoothness)
        settings.crosshair.lastMousePosition = crosshairCenter
    end

    -- Apply sine wave to size if enabled
    local currentSize = settings.crosshair.size
    if settings.crosshair.sineSpeed > 0 then
        currentSize = settings.crosshair.size + (math.sin(tick() * settings.crosshair.sineSpeed) * (settings.crosshair.size * settings.crosshair.sineStrength))
    end
    
    -- Apply sine wave to gap if enabled
    local currentGapSize = settings.crosshair.gapSize
    if settings.crosshair.gapSineSpeed > 0 then
        currentGapSize = settings.crosshair.gapSize + (math.sin(tick() * settings.crosshair.gapSineSpeed) * (settings.crosshair.gapSize * settings.crosshair.gapSineStrength))
    end
    
    -- Update spin angle if enabled
    if settings.crosshair.spinSpeed > 0 then
        settings.crosshair.angle = (settings.crosshair.angle + settings.crosshair.spinSpeed) % 360
    end
    
    -- Calculate rotated points for crosshair lines
    local angle = settings.crosshair.angle
    
    local topX, topY = rotatePoint(crosshairCenter.X, crosshairCenter.Y - currentSize, crosshairCenter.X, crosshairCenter.Y, angle)
    local bottomX, bottomY = rotatePoint(crosshairCenter.X, crosshairCenter.Y + currentSize, crosshairCenter.X, crosshairCenter.Y, angle)
    local leftX, leftY = rotatePoint(crosshairCenter.X - currentSize, crosshairCenter.Y, crosshairCenter.X, crosshairCenter.Y, angle)
    local rightX, rightY = rotatePoint(crosshairCenter.X + currentSize, crosshairCenter.Y, crosshairCenter.X, crosshairCenter.Y, angle)
    
    local topInnerX, topInnerY = rotatePoint(crosshairCenter.X, crosshairCenter.Y - currentGapSize, crosshairCenter.X, crosshairCenter.Y, angle)
    local bottomInnerX, bottomInnerY = rotatePoint(crosshairCenter.X, crosshairCenter.Y + currentGapSize, crosshairCenter.X, crosshairCenter.Y, angle)
    local leftInnerX, leftInnerY = rotatePoint(crosshairCenter.X - currentGapSize, crosshairCenter.Y, crosshairCenter.X, crosshairCenter.Y, angle)
    local rightInnerX, rightInnerY = rotatePoint(crosshairCenter.X + currentGapSize, crosshairCenter.Y, crosshairCenter.X, crosshairCenter.Y, angle)
    
    -- Update crosshair lines
    for _, line in pairs(settings.crosshair.lines) do
        line.Visible = true
        line.Color = settings.crosshair.color
        line.Thickness = settings.crosshair.thickness
    end
    
    -- Top line
    settings.crosshair.lines.top.From = Vector2.new(topInnerX, topInnerY)
    settings.crosshair.lines.top.To = Vector2.new(topX, topY)
    
    -- Bottom line
    settings.crosshair.lines.bottom.From = Vector2.new(bottomInnerX, bottomInnerY)
    settings.crosshair.lines.bottom.To = Vector2.new(bottomX, bottomY)
    
    -- Left line
    settings.crosshair.lines.left.From = Vector2.new(leftInnerX, leftInnerY)
    settings.crosshair.lines.left.To = Vector2.new(leftX, leftY)
    
    -- Right line
    settings.crosshair.lines.right.From = Vector2.new(rightInnerX, rightInnerY)
    settings.crosshair.lines.right.To = Vector2.new(rightX, rightY)
    
    -- Update outline lines
    for _, line in pairs(settings.crosshair.outlines) do
        line.Visible = true
        line.Color = settings.crosshair.outlineColor
        line.Thickness = settings.crosshair.outlineThickness
    end
    
    -- Top outline
    settings.crosshair.outlines.top.From = settings.crosshair.lines.top.From
    settings.crosshair.outlines.top.To = settings.crosshair.lines.top.To
    
    -- Bottom outline
    settings.crosshair.outlines.bottom.From = settings.crosshair.lines.bottom.From
    settings.crosshair.outlines.bottom.To = settings.crosshair.lines.bottom.To
    
    -- Left outline
    settings.crosshair.outlines.left.From = settings.crosshair.lines.left.From
    settings.crosshair.outlines.left.To = settings.crosshair.lines.left.To
    
    -- Right outline
    settings.crosshair.outlines.right.From = settings.crosshair.lines.right.From
    settings.crosshair.outlines.right.To = settings.crosshair.lines.right.To
    
    -- Update center panel text
    if settings.crosshair.centerPanel.enabled then
        settings.crosshair.centerPanel.instance.Visible = true
        settings.crosshair.centerPanel.instance.Text = settings.crosshair.centerPanel.text
        settings.crosshair.centerPanel.instance.Size = settings.crosshair.centerPanel.textSize
        settings.crosshair.centerPanel.instance.Position = Vector2.new(
            crosshairCenter.X, 
            crosshairCenter.Y + settings.crosshair.centerPanel.offset.Y
        )
        settings.crosshair.centerPanel.instance.Color = settings.crosshair.centerPanel.color
        settings.crosshair.centerPanel.instance.OutlineColor = settings.crosshair.centerPanel.outlineColor
        settings.crosshair.centerPanel.instance.Transparency = settings.crosshair.centerPanel.transparency
    else
        settings.crosshair.centerPanel.instance.Visible = false
    end
end

-- Save original player data when script loads
saveOriginalPlayerData()

-- Connect to character added event to save data for new characters
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    wait(1) -- Wait for character to fully load
    saveOriginalPlayerData()

    -- Reapply material if enabled
    if flags["Player_Material"] then
        applyPlayerMaterial()
    end

    -- Reapply highlight if enabled
    if settings.highlight.enabled then
        updatePlayerHighlight()
    end
end)

-- Create a RenderStepped connection for footsteps and crosshair
local visualEffectsConnection = nil
local function setupVisualEffectsConnection()
    if visualEffectsConnection then
        visualEffectsConnection:Disconnect()
        visualEffectsConnection = nil
    end

    if settings.footsteps.enabled or settings.crosshair.enabled then
        visualEffectsConnection = game:GetService("RunService").RenderStepped:Connect(function()
            if settings.footsteps.enabled then
                updateFootstepCircles()
            end
            if settings.crosshair.enabled then
                updateCrosshair()
            end
        end)
    else
        -- Make sure crosshair is hidden when disabled
        hideCrosshair()
    end
end

-- Add UI elements for local visuals
local_visuals:toggle({
    name = "Custom Material",
    flag = "Player_Material",
    callback = function(value)
        if value then
            saveOriginalPlayerData()
            applyPlayerMaterial()
        else
            resetPlayerVisuals()
        end
    end
})

local_visuals:dropdown({
    name = "Material Type",
    flag = "Player_Material_Type",
    items = {"Plastic", "SmoothPlastic", "Neon", "ForceField", "Glass"},
    default = "Plastic",
    callback = function(value)
        if value == "Plastic" then
            settings.player.material = Enum.Material.Plastic
        elseif value == "SmoothPlastic" then
            settings.player.material = Enum.Material.SmoothPlastic
        elseif value == "Neon" then
            settings.player.material = Enum.Material.Neon
        elseif value == "ForceField" then
            settings.player.material = Enum.Material.ForceField
        elseif value == "Glass" then
            settings.player.material = Enum.Material.Glass
        end
        
        if flags["Player_Material"] then
            applyPlayerMaterial()
        end
    end
})

local_visuals:colorpicker({
    name = "Material Color",
    flag = "Player_Material_Color",
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        settings.player.color = color
        updatePlayerVisuals()
    end
})

local_visuals:slider({
    name = "Transparency",
    flag = "Player_Material_Transparency",
    min = 0,
    max = 1,
    default = 0,
    interval = 0.01,
    callback = function(value)
        settings.player.transparency = value
        updatePlayerVisuals()
    end
})

local_visuals:toggle({
    name = "Highlight",
    flag = "Player_Highlight",
    callback = function(value)
        settings.highlight.enabled = value
        updatePlayerHighlight()
    end
})

local_visuals:colorpicker({
    name = "Highlight Fill Color",
    flag = "Player_Highlight_Fill_Color",
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        settings.highlight.fillColor = color
        if settings.highlight.instance then
            settings.highlight.instance.FillColor = color
        end
    end
})

local_visuals:colorpicker({
    name = "Highlight Outline Color",
    flag = "Player_Highlight_Outline_Color",
    default = Color3.fromRGB(0, 170, 255),
    callback = function(color)
        settings.highlight.outlineColor = color
        if settings.highlight.instance then
            settings.highlight.instance.OutlineColor = color
        end
    end
})

local_visuals:toggle({
    name = "Footstep Circles",
    flag = "Player_Footstep_Circles",
    callback = function(value)
        settings.footsteps.enabled = value
        if not value then
            clearFootstepCircles()
        end
        setupVisualEffectsConnection()
    end
})

local_visuals:dropdown({
    name = "Footstep Animation",
    flag = "Player_Footstep_Animation",
    items = {"In", "Out"},
    default = "In",
    callback = function(value)
        settings.footsteps.mode = value
    end
})

local_visuals:slider({
    name = "Footstep Size",
    flag = "Player_Footstep_Size",
    min = 0.5,
    max = 5,
    default = 1,
    interval = 0.1,
    callback = function(value)
        settings.footsteps.size = value
    end
})

local_visuals:colorpicker({
    name = "Footstep Color",
    flag = "Player_Footstep_Color",
    default = Color3.fromRGB(0, 170, 255),
    callback = function(color)
        settings.footsteps.color = color
    end
})

local_visuals:slider({
    name = "Footstep Lifetime",
    flag = "Player_Footstep_Lifetime",
    min = 0.5,
    max = 5,
    default = 2,
    interval = 0.1,
    callback = function(value)
        settings.footsteps.lifetime = value
    end
})

-- Add UI elements for crosshair
crosshair_section:toggle({
    name = "Enable Crosshair",
    flag = "Crosshair_Enabled",
    callback = function(value)
        settings.crosshair.enabled = value
        setupVisualEffectsConnection()
    end
})

crosshair_section:dropdown({
    name = "Crosshair Mode",
    flag = "Crosshair_Mode",
    items = {"Center", "Follow Mouse"},
    default = "Center",
    callback = function(value)
        settings.crosshair.method = value
    end
})

crosshair_section:slider({
    name = "Follow Smoothness",
    flag = "Crosshair_Follow_Smoothness",
    min = 0.01,
    max = 1,
    default = 0.2,
    interval = 0.01,
    callback = function(value)
        settings.crosshair.followSmoothness = value
    end
})

crosshair_section:slider({
    name = "Size",
    flag = "Crosshair_Size",
    min = 5,
    max = 50,
    default = 10,
    interval = 1,
    callback = function(value)
        settings.crosshair.size = value
    end
})

crosshair_section:slider({
    name = "Thickness",
    flag = "Crosshair_Thickness",
    min = 0.5,
    max = 5,
    default = 1.5,
    interval = 0.1,
    callback = function(value)
        settings.crosshair.thickness = value
        settings.crosshair.outlineThickness = value * 2
    end
})

crosshair_section:slider({
    name = "Gap Size",
    flag = "Crosshair_Gap_Size",
    min = 0,
    max = 20,
    default = 2,
    interval = 1,
    callback = function(value)
        settings.crosshair.gapSize = value
    end
})

crosshair_section:slider({
    name = "Spin Speed",
    flag = "Crosshair_Spin_Speed",
    min = 0,
    max = 10,
    default = 0,
    interval = 0.1,
    callback = function(value)
        settings.crosshair.spinSpeed = value
    end
})

crosshair_section:slider({
    name = "Sine Speed",
    flag = "Crosshair_Sine_Speed",
    min = 0,
    max = 10,
    default = 0,
    interval = 0.1,
    callback = function(value)
        settings.crosshair.sineSpeed = value
    end
})

crosshair_section:slider({
    name = "Sine Strength",
    flag = "Crosshair_Sine_Strength",
    min = 0.1,
    max = 1,
    default = 0.3,
    interval = 0.05,
    callback = function(value)
        settings.crosshair.sineStrength = value
    end
})

crosshair_section:slider({
    name = "Gap Sine Speed",
    flag = "Crosshair_Gap_Sine_Speed",
    min = 0,
    max = 10,
    default = 0,
    interval = 0.1,
    callback = function(value)
        settings.crosshair.gapSineSpeed = value
    end
})

crosshair_section:slider({
    name = "Gap Sine Strength",
    flag = "Crosshair_Gap_Sine_Strength",
    min = 0.1,
    max = 1,
    default = 0.5,
    interval = 0.05,
    callback = function(value)
        settings.crosshair.gapSineStrength = value
    end
})

crosshair_section:colorpicker({
    name = "Crosshair Color",
    flag = "Crosshair_Color",
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        settings.crosshair.color = color
    end
})

crosshair_section:colorpicker({
    name = "Outline Color",
    flag = "Crosshair_Outline_Color",
    default = Color3.fromRGB(0, 0, 0),
    callback = function(color)
        settings.crosshair.outlineColor = color
    end
})

-- Add UI elements for center panel
crosshair_section:toggle({
    name = "Center Panel Text",
    flag = "Crosshair_Center_Panel",
    default = true,
    callback = function(value)
        settings.crosshair.centerPanel.enabled = value
    end
})

crosshair_section:textbox({
    name = "Panel Text",
    flag = "Crosshair_Panel_Text",
    default = "Oracle.net",
    callback = function(value)
        settings.crosshair.centerPanel.text = value
    end
})

crosshair_section:slider({
    name = "Text Size",
    flag = "Crosshair_Text_Size",
    min = 10,
    max = 30,
    default = 16,
    interval = 1,
    callback = function(value)
        settings.crosshair.centerPanel.textSize = value
    end
})

crosshair_section:slider({
    name = "Text Y Offset",
    flag = "Crosshair_Text_Offset",
    min = -50,
    max = 50,
    default = 15,
    interval = 1,
    callback = function(value)
        settings.crosshair.centerPanel.offset = Vector2.new(0, value)
    end
})

crosshair_section:colorpicker({
    name = "Text Color",
    flag = "Crosshair_Text_Color",
    default = Color3.fromRGB(255, 255, 255),
    callback = function(color)
        settings.crosshair.centerPanel.color = color
    end
})

crosshair_section:colorpicker({
    name = "Text Outline Color",
    flag = "Crosshair_Text_Outline_Color",
    default = Color3.fromRGB(0, 0, 0),
    callback = function(color)
        settings.crosshair.centerPanel.outlineColor = color
    end
})



-- Create ESP module
local ESP = {
    Enabled = false,
    BoxESP = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 1,
        TeamCheck = false,
        BoxFill = false,
        BoxFillColor = Color3.fromRGB(255, 255, 255),
        BoxFillTransparency = 0.5,
        BoxOutline = true,
        BoxOutlineColor = Color3.fromRGB(0, 0, 0),
        BoxOutlineThickness = 3,
        RoundedCorners = true,
        CornerRadius = 5,
        -- Checks
        CheckVisible = true,
        CheckKnocked = true,
        CheckDead = true,
        CheckCrew = true,
        CheckGrabbed = true
    },
    NameESP = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 1,
        DisplayType = "Username", -- "Username", "DisplayName", or "Both"
        Offset = Vector2.new(0, -15),
        Font = Drawing.Fonts.UI,
        Size = 16,
        Bold = true,
        ShowDistance = true,
        DistanceFormat = "[%d m]"
    },
    Highlight = {
        Enabled = false,
        FillColor = Color3.fromRGB(255, 0, 0),
        FillTransparency = 0.5,
        OutlineColor = Color3.fromRGB(255, 255, 255),
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    },
    ToolESP = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 1,
        Font = Drawing.Fonts.UI,
        Size = 14,
        ShowIcon = true,
        IconSize = Vector2.new(16, 16)
    },
    Healthbar = {
        Enabled = false,
        Color = Color3.fromRGB(0, 255, 0),
        Position = "Left", -- "Left", "Right", "Top", "Bottom"
        Thickness = 3,
        Offset = 3,
        Outline = true,
        OutlineColor = Color3.fromRGB(0, 0, 0),
        OutlineThickness = 1,
        Animated = true,
        AnimationSpeed = 0.5,
        ShowValue = false
    },
    Armorbar = {
        Enabled = false,
        Color = Color3.fromRGB(0, 170, 255),
        Position = "Right", -- "Left", "Right", "Top", "Bottom"
        Thickness = 3,
        Offset = 3,
        Outline = true,
        OutlineColor = Color3.fromRGB(0, 0, 0),
        OutlineThickness = 1,
        Animated = true,
        AnimationSpeed = 0.5,
        ShowValue = false
    },
    Tracers = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 1,
        Thickness = 1,
        Origin = "Bottom", -- "Bottom", "Center", "Mouse"
        Target = "HumanoidRootPart" -- "HumanoidRootPart", "Head", "Feet"
    },
    Chams = {
        Enabled = false,
        FillColor = Color3.fromRGB(255, 0, 0),
        FillTransparency = 0.5,
        OutlineColor = Color3.fromRGB(255, 255, 255),
        OutlineTransparency = 0,
        VisibleOnly = true
    },
    DrawingObjects = {},
    AnimatedValues = {}
}

-- Function to create ESP for a player
function ESP:CreatePlayerESP(player)
    if player == game.Players.LocalPlayer then return end
    
    local esp = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        BoxFill = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        Tool = Drawing.new("Text"),
        ToolIcon = Drawing.new("Image"),
        Healthbar = Drawing.new("Square"),
        Healthbar_Outline = Drawing.new("Square"),
        HealthText = Drawing.new("Text"),
        Armorbar = Drawing.new("Square"),
        Armorbar_Outline = Drawing.new("Square"),
        ArmorText = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        Highlight = nil, -- Will be created when needed
        Chams = nil -- Will be created when needed
    }
    
    -- Box outline settings
    esp.BoxOutline.Visible = false
    esp.BoxOutline.Color = self.BoxESP.BoxOutlineColor
    esp.BoxOutline.Thickness = self.BoxESP.BoxOutlineThickness
    esp.BoxOutline.Transparency = 1
    esp.BoxOutline.Filled = false
    
    -- Box settings
    esp.Box.Visible = false
    esp.Box.Color = self.BoxESP.Color
    esp.Box.Thickness = 1
    esp.Box.Transparency = self.BoxESP.Transparency
    
    -- Box fill settings
    esp.BoxFill.Visible = false
    esp.BoxFill.Color = self.BoxESP.BoxFillColor
    esp.BoxFill.Thickness = 1
    esp.BoxFill.Transparency = self.BoxESP.BoxFillTransparency
    esp.BoxFill.Filled = true
    
    -- Name settings
    esp.Name.Visible = false
    esp.Name.Color = self.NameESP.Color
    esp.Name.Size = self.NameESP.Size
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.OutlineColor = Color3.new(0, 0, 0)
    esp.Name.Transparency = self.NameESP.Transparency
    esp.Name.Font = self.NameESP.Font
    
    -- Distance settings
    esp.Distance.Visible = false
    esp.Distance.Color = self.NameESP.Color
    esp.Distance.Size = self.NameESP.Size - 2
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.OutlineColor = Color3.new(0, 0, 0)
    esp.Distance.Transparency = self.NameESP.Transparency
    esp.Distance.Font = self.NameESP.Font
    
    -- Tool settings
    esp.Tool.Visible = false
    esp.Tool.Color = self.ToolESP.Color
    esp.Tool.Size = self.ToolESP.Size
    esp.Tool.Center = true
    esp.Tool.Outline = true
    esp.Tool.OutlineColor = Color3.new(0, 0, 0)
    esp.Tool.Transparency = self.ToolESP.Transparency
    esp.Tool.Font = self.ToolESP.Font
    
    -- Tool icon settings
    esp.ToolIcon.Visible = false
    esp.ToolIcon.Size = self.ToolESP.IconSize
    esp.ToolIcon.Transparency = self.ToolESP.Transparency
    
    -- Health bar outline settings
    esp.Healthbar_Outline.Visible = false
    esp.Healthbar_Outline.Color = self.Healthbar.OutlineColor
    esp.Healthbar_Outline.Thickness = self.Healthbar.OutlineThickness
    esp.Healthbar_Outline.Transparency = 1
    esp.Healthbar_Outline.Filled = false
    
    -- Health bar settings
    esp.Healthbar.Visible = false
    esp.Healthbar.Color = self.Healthbar.Color
    esp.Healthbar.Thickness = self.Healthbar.Thickness
    esp.Healthbar.Transparency = 1
    esp.Healthbar.Filled = true
    
    -- Health text settings
    esp.HealthText.Visible = false
    esp.HealthText.Color = Color3.new(1, 1, 1)
    esp.HealthText.Size = 12
    esp.HealthText.Center = true
    esp.HealthText.Outline = true
    esp.HealthText.OutlineColor = Color3.new(0, 0, 0)
    esp.HealthText.Transparency = 1
    esp.HealthText.Font = Drawing.Fonts.UI
    
    -- Armor bar outline settings
    esp.Armorbar_Outline.Visible = false
    esp.Armorbar_Outline.Color = self.Armorbar.OutlineColor
    esp.Armorbar_Outline.Thickness = self.Armorbar.OutlineThickness
    esp.Armorbar_Outline.Transparency = 1
    esp.Armorbar_Outline.Filled = false
    
    -- Armor bar settings
    esp.Armorbar.Visible = false
    esp.Armorbar.Color = self.Armorbar.Color
    esp.Armorbar.Thickness = self.Armorbar.Thickness
    esp.Armorbar.Transparency = 1
    esp.Armorbar.Filled = true
    
    -- Armor text settings
    esp.ArmorText.Visible = false
    esp.ArmorText.Color = Color3.new(1, 1, 1)
    esp.ArmorText.Size = 12
    esp.ArmorText.Center = true
    esp.ArmorText.Outline = true
    esp.ArmorText.OutlineColor = Color3.new(0, 0, 0)
    esp.ArmorText.Transparency = 1
    esp.ArmorText.Font = Drawing.Fonts.UI
    
    -- Tracer settings
    esp.Tracer.Visible = false
    esp.Tracer.Color = self.Tracers.Color
    esp.Tracer.Thickness = self.Tracers.Thickness
    esp.Tracer.Transparency = self.Tracers.Transparency
    
    -- Store animated values
    self.AnimatedValues[player] = {
        Health = 100,
        Armor = 0
    }
    
    self.DrawingObjects[player] = esp
end

-- Function to remove ESP for a player
function ESP:RemovePlayerESP(player)
    if self.DrawingObjects[player] then
        for key, drawing in pairs(self.DrawingObjects[player]) do
            if key ~= "Highlight" and key ~= "Chams" and drawing.Remove then
                drawing:Remove()
            elseif (key == "Highlight" or key == "Chams") and drawing then
                drawing:Destroy()
            end
        end
        self.DrawingObjects[player] = nil
        self.AnimatedValues[player] = nil
    end
end

-- Function to check if a player is knocked (Da Hood specific)
function ESP:IsPlayerKnocked(player)
    if not self.BoxESP.CheckKnocked then return false end
    
    local character = player.Character
    if not character then return true end
    
    -- Da Hood specific check for knocked state
    if character:FindFirstChild("BodyEffects") and 
       character.BodyEffects:FindFirstChild("K.O") and 
       character.BodyEffects["K.O"].Value then
        return true
    end
    
    return false
end

-- Function to check if a player is dead (Da Hood specific)
function ESP:IsPlayerDead(player)
    if not self.BoxESP.CheckDead then return false end
    
    local character = player.Character
    if not character then return true end
    
    -- Check if humanoid exists and health is 0
    if character:FindFirstChild("Humanoid") and character.Humanoid.Health <= 0 then
        return true
    end
    
    return false
end

-- Function to check if a player is in the same crew (Da Hood specific)
function ESP:IsPlayerInSameCrew(player)
    if not self.BoxESP.CheckCrew then return false end
    
    -- Da Hood specific crew check
    local localPlayer = game.Players.LocalPlayer
    
    -- Check if both players have the same crew tag
    if player:FindFirstChild("DataFolder") and 
       player.DataFolder:FindFirstChild("Information") and 
       player.DataFolder.Information:FindFirstChild("Crew") and
       localPlayer:FindFirstChild("DataFolder") and
       localPlayer.DataFolder:FindFirstChild("Information") and
       localPlayer.DataFolder.Information:FindFirstChild("Crew") then
        
        local playerCrew = player.DataFolder.Information.Crew.Value
        local localCrew = localPlayer.DataFolder.Information.Crew.Value
        
        if playerCrew ~= "" and playerCrew == localCrew then
            return true
        end
    end
    
    return false
end

-- Function to check if a player is grabbed (Da Hood specific)
function ESP:IsPlayerGrabbed(player)
    if not self.BoxESP.CheckGrabbed then return false end
    
    local character = player.Character
    if not character then return true end
    
    -- Da Hood specific check for grabbed state
    if character:FindFirstChild("GRABBING_CONSTRAINT") then
        return true
    end
    
    return false
end

-- Function to check if a player is visible
function ESP:IsPlayerVisible(player)
    if not self.BoxESP.CheckVisible then return true end
    
    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return false end
    
    local head = character.Head
    local rayOrigin = game.Workspace.CurrentCamera.CFrame.Position
    local rayDirection = (head.Position - rayOrigin).Unit
    local rayDistance = (head.Position - rayOrigin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character, character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = game.Workspace:Raycast(rayOrigin, rayDirection * rayDistance, raycastParams)
    
    return raycastResult == nil
end

-- Function to get player's equipped tool
function ESP:GetPlayerTool(player)
    local character = player.Character
    if not character then return "None" end
    
    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") then
            return child.Name
        end
    end
    
    return "None"
end

-- Function to get player's name based on display type
function ESP:GetPlayerName(player)
    if self.NameESP.DisplayType == "Username" then
        return player.Name
    elseif self.NameESP.DisplayType == "DisplayName" then
        return player.DisplayName
    else -- "Both"
        if player.Name ~= player.DisplayName then
            return player.DisplayName .. " (" .. player.Name .. ")"
        else
            return player.Name
        end
    end
end

-- Function to update highlight
function ESP:UpdateHighlight(player, esp, character)
    if not self.Highlight.Enabled or not character then
        if esp.Highlight then
            esp.Highlight.Enabled = false
        end
        return
    end
    
    -- Create highlight if it doesn't exist
    if not esp.Highlight then
        esp.Highlight = Instance.new("Highlight")
        esp.Highlight.Adornee = character
        esp.Highlight.DepthMode = self.Highlight.DepthMode
        esp.Highlight.Parent = game.CoreGui
    end
    
    -- Update highlight properties
    esp.Highlight.Enabled = self.Enabled and self.Highlight.Enabled
    esp.Highlight.FillColor = self.Highlight.FillColor
    esp.Highlight.FillTransparency = self.Highlight.FillTransparency
    esp.Highlight.OutlineColor = self.Highlight.OutlineColor
    esp.Highlight.OutlineTransparency = self.Highlight.OutlineTransparency
end

-- Function to update chams
function ESP:UpdateChams(player, esp, character)
    if not self.Chams.Enabled or not character then
        if esp.Chams then
            esp.Chams.Enabled = false
        end
        return
    end
    
    -- Check if player is visible (if VisibleOnly is enabled)
    if self.Chams.VisibleOnly and not self:IsPlayerVisible(player) then
        if esp.Chams then
            esp.Chams.Enabled = false
        end
        return
    end
    
    -- Create chams if it doesn't exist
    if not esp.Chams then
        esp.Chams = Instance.new("Highlight")
        esp.Chams.Adornee = character
        esp.Chams.DepthMode = Enum.HighlightDepthMode.Occluded
        esp.Chams.Parent = game.CoreGui
    end
    
    -- Update chams properties
    esp.Chams.Enabled = self.Enabled and self.Chams.Enabled
    esp.Chams.FillColor = self.Chams.FillColor
    esp.Chams.FillTransparency = self.Chams.FillTransparency
    esp.Chams.OutlineColor = self.Chams.OutlineColor
    esp.Chams.OutlineTransparency = self.Chams.OutlineTransparency
end

-- Function to get player's armor (Da Hood specific)
function ESP:GetPlayerArmor(player)
    local character = player.Character
    if not character then return 0 end
    
    -- Da Hood specific armor check
    if character:FindFirstChild("BodyEffects") and 
       character.BodyEffects:FindFirstChild("Armor") then
        return character.BodyEffects.Armor.Value
    end
    
    return 0
end

-- Function to update health bar with animation
function ESP:UpdateHealthBar(player, esp, character, boxPosition, boxSize)
    if not self.Healthbar.Enabled or not character or not character:FindFirstChild("Humanoid") then
        esp.Healthbar.Visible = false
        esp.Healthbar_Outline.Visible = false
        esp.HealthText.Visible = false
        return
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local health = humanoid.Health
    local maxHealth = humanoid.MaxHealth
    
    -- Animate health value
    if self.Healthbar.Animated and self.AnimatedValues[player] then
        local currentAnimatedHealth = self.AnimatedValues[player].Health
        local targetHealth = health / maxHealth * 100
        
        -- Smoothly animate towards target health
        self.AnimatedValues[player].Health = currentAnimatedHealth + 
            (targetHealth - currentAnimatedHealth) * 
            (self.Healthbar.AnimationSpeed * (1/60))
        
        -- Ensure we don't overshoot
        if targetHealth > currentAnimatedHealth then
            self.AnimatedValues[player].Health = math.min(self.AnimatedValues[player].Health, targetHealth)
        else
            self.AnimatedValues[player].Health = math.max(self.AnimatedValues[player].Health, targetHealth)
        end
        
        -- Use animated health percentage
        local healthPercent = self.AnimatedValues[player].Health / 100
        healthPercent = math.clamp(healthPercent, 0, 1)
    else
        -- Use actual health percentage without animation
        local healthPercent = math.clamp(health / maxHealth, 0, 1)
        self.AnimatedValues[player].Health = healthPercent * 100
    end
    
    local healthPercent = self.AnimatedValues[player].Health / 100
    
    -- Calculate health bar position and size based on settings
    local healthbarPosition = self.Healthbar.Position
    
    if healthbarPosition == "Left" then
        -- Health bar outline
        esp.Healthbar_Outline.Size = Vector2.new(self.Healthbar.Thickness + 2, boxSize.Y)
        esp.Healthbar_Outline.Position = Vector2.new(boxPosition.X - self.Healthbar.Offset - 1, boxPosition.Y)
        
        -- Health bar fill
        esp.Healthbar.Size = Vector2.new(self.Healthbar.Thickness, (healthPercent * boxSize.Y))
        esp.Healthbar.Position = Vector2.new(boxPosition.X - self.Healthbar.Offset, boxPosition.Y + (boxSize.Y - esp.Healthbar.Size.Y))
        
        -- Health text
        if self.Healthbar.ShowValue then
            esp.HealthText.Text = math.floor(healthPercent * 100) .. "%"
            esp.HealthText.Position = Vector2.new(
                boxPosition.X - self.Healthbar.Offset - self.Healthbar.Thickness - 5,
                boxPosition.Y + boxSize.Y - 15
            )
        end
        
    elseif healthbarPosition == "Right" then
        -- Health bar outline
        esp.Healthbar_Outline.Size = Vector2.new(self.Healthbar.Thickness + 2, boxSize.Y)
        esp.Healthbar_Outline.Position = Vector2.new(boxPosition.X + boxSize.X + self.Healthbar.Offset - 1, boxPosition.Y)
        
        -- Health bar fill
        esp.Healthbar.Size = Vector2.new(self.Healthbar.Thickness, (healthPercent * boxSize.Y))
        esp.Healthbar.Position = Vector2.new(boxPosition.X + boxSize.X + self.Healthbar.Offset, boxPosition.Y + (boxSize.Y - esp.Healthbar.Size.Y))
        
        -- Health text
        if self.Healthbar.ShowValue then
            esp.HealthText.Text = math.floor(healthPercent * 100) .. "%"
            esp.HealthText.Position = Vector2.new(
                boxPosition.X + boxSize.X + self.Healthbar.Offset + self.Healthbar.Thickness + 5,
                boxPosition.Y + boxSize.Y - 15
            )
        end
        
    elseif healthbarPosition == "Top" then
        -- Health bar outline
        esp.Healthbar_Outline.Size = Vector2.new(boxSize.X, self.Healthbar.Thickness + 2)
        esp.Healthbar_Outline.Position = Vector2.new(boxPosition.X, boxPosition.Y - self.Healthbar.Offset - 1)
        
        -- Health bar fill
        esp.Healthbar.Size = Vector2.new((healthPercent * boxSize.X), self.Healthbar.Thickness)
        esp.Healthbar.Position = Vector2.new(boxPosition.X, boxPosition.Y - self.Healthbar.Offset)
        
        -- Health text
        if self.Healthbar.ShowValue then
            esp.HealthText.Text = math.floor(healthPercent * 100) .. "%"
            esp.HealthText.Position = Vector2.new(
                boxPosition.X + (boxSize.X / 2),
                boxPosition.Y - self.Healthbar.Offset - self.Healthbar.Thickness - 10
            )
        end
        
    elseif healthbarPosition == "Bottom" then
        -- Health bar outline
        esp.Healthbar_Outline.Size = Vector2.new(boxSize.X, self.Healthbar.Thickness + 2)
        esp.Healthbar_Outline.Position = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y + self.Healthbar.Offset - 1)
        
        -- Health bar fill
        esp.Healthbar.Size = Vector2.new((healthPercent * boxSize.X), self.Healthbar.Thickness)
        esp.Healthbar.Position = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y + self.Healthbar.Offset)
        
        -- Health text
        if self.Healthbar.ShowValue then
            esp.HealthText.Text = math.floor(healthPercent * 100) .. "%"
            esp.HealthText.Position = Vector2.new(
                boxPosition.X + (boxSize.X / 2),
                boxPosition.Y + boxSize.Y + self.Healthbar.Offset + self.Healthbar.Thickness + 5
            )
        end
    end
    
    -- Make health bar visible
    esp.Healthbar.Visible = self.Enabled and self.Healthbar.Enabled
    esp.Healthbar_Outline.Visible = self.Enabled and self.Healthbar.Enabled and self.Healthbar.Outline
    esp.HealthText.Visible = self.Enabled and self.Healthbar.Enabled and self.Healthbar.ShowValue
    
    -- Fix transparency to make health bar more visible
    esp.Healthbar.Transparency = 1
    esp.Healthbar_Outline.Transparency = 1
    esp.HealthText.Transparency = 1
end

-- Function to update armor bar with animation
function ESP:UpdateArmorBar(player, esp, character, boxPosition, boxSize)
    if not self.Armorbar.Enabled or not character then
        esp.Armorbar.Visible = false
        esp.Armorbar_Outline.Visible = false
        esp.ArmorText.Visible = false
        return
    end
    
    local armor = self:GetPlayerArmor(player)
    local maxArmor = 100 -- Da Hood max armor is typically 100
    
    -- Animate armor value
    if self.Armorbar.Animated and self.AnimatedValues[player] then
        local currentAnimatedArmor = self.AnimatedValues[player].Armor
        local targetArmor = armor / maxArmor * 100
        
        -- Smoothly animate towards target armor
        self.AnimatedValues[player].Armor = currentAnimatedArmor + 
            (targetArmor - currentAnimatedArmor) * 
            (self.Armorbar.AnimationSpeed * (1/60))
        
        -- Ensure we don't overshoot
        if targetArmor > currentAnimatedArmor then
            self.AnimatedValues[player].Armor = math.min(self.AnimatedValues[player].Armor, targetArmor)
        else
            self.AnimatedValues[player].Armor = math.max(self.AnimatedValues[player].Armor, targetArmor)
        end
        
        -- Use animated armor percentage
        local armorPercent = self.AnimatedValues[player].Armor / 100
        armorPercent = math.clamp(armorPercent, 0, 1)
    else
        -- Use actual armor percentage without animation
        local armorPercent = math.clamp(armor / maxArmor, 0, 1)
        self.AnimatedValues[player].Armor = armorPercent * 100
    end
    
    local armorPercent = self.AnimatedValues[player].Armor / 100
    
    -- If no armor, don't show the bar
    if armorPercent <= 0 then
        esp.Armorbar.Visible = false
        esp.Armorbar_Outline.Visible = false
        esp.ArmorText.Visible = false
        return
    end
    
    -- Calculate armor bar position and size based on settings
    local armorbarPosition = self.Armorbar.Position
    
    if armorbarPosition == "Left" then
        -- Armor bar outline
        esp.Armorbar_Outline.Size = Vector2.new(self.Armorbar.Thickness + 2, boxSize.Y)
        esp.Armorbar_Outline.Position = Vector2.new(boxPosition.X - self.Armorbar.Offset - self.Armorbar.Thickness - 3, boxPosition.Y)
        
        -- Armor bar fill
        esp.Armorbar.Size = Vector2.new(self.Armorbar.Thickness, (armorPercent * boxSize.Y))
        esp.Armorbar.Position = Vector2.new(boxPosition.X - self.Armorbar.Offset - self.Armorbar.Thickness - 2, boxPosition.Y + (boxSize.Y - esp.Armorbar.Size.Y))
        
        -- Armor text
        if self.Armorbar.ShowValue then
            esp.ArmorText.Text = math.floor(armorPercent * 100) .. "%"
            esp.ArmorText.Position = Vector2.new(
                boxPosition.X - self.Armorbar.Offset - self.Armorbar.Thickness * 2 - 5,
                boxPosition.Y + boxSize.Y - 15
            )
        end
        
    elseif armorbarPosition == "Right" then
        -- Armor bar outline
        esp.Armorbar_Outline.Size = Vector2.new(self.Armorbar.Thickness + 2, boxSize.Y)
        esp.Armorbar_Outline.Position = Vector2.new(boxPosition.X + boxSize.X + self.Armorbar.Offset - 1, boxPosition.Y)
        
        -- Armor bar fill
        esp.Armorbar.Size = Vector2.new(self.Armorbar.Thickness, (armorPercent * boxSize.Y))
        esp.Armorbar.Position = Vector2.new(boxPosition.X + boxSize.X + self.Armorbar.Offset, boxPosition.Y + (boxSize.Y - esp.Armorbar.Size.Y))
        
    elseif armorbarPosition == "Top" then
        -- Armor bar outline
        esp.Armorbar_Outline.Size = Vector2.new(boxSize.X, self.Armorbar.Thickness + 2)
        esp.Armorbar_Outline.Position = Vector2.new(boxPosition.X, boxPosition.Y - self.Armorbar.Offset - 1)
        
        -- Armor bar fill
        esp.Armorbar.Size = Vector2.new((armorPercent * boxSize.X), self.Armorbar.Thickness)
        esp.Armorbar.Position = Vector2.new(boxPosition.X, boxPosition.Y - self.Armorbar.Offset)
        
    elseif armorbarPosition == "Bottom" then
        -- Armor bar outline
        esp.Armorbar_Outline.Size = Vector2.new(boxSize.X, self.Armorbar.Thickness + 2)
        esp.Armorbar_Outline.Position = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y + self.Armorbar.Offset - 1)
        
        -- Armor bar fill
        esp.Armorbar.Size = Vector2.new((armorPercent * boxSize.X), self.Armorbar.Thickness)
        esp.Armorbar.Position = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y + self.Armorbar.Offset)
    end
    
    -- Make armor bar visible
    esp.Armorbar.Visible = self.Enabled and self.Armorbar.Enabled and armorPercent > 0
    esp.Armorbar_Outline.Visible = self.Enabled and self.Armorbar.Enabled and armorPercent > 0
    
    -- Fix transparency to make armor bar more visible
    esp.Armorbar.Transparency = 1
    esp.Armorbar_Outline.Transparency = 0.2
end

-- Function to update ESP
function ESP:Update()
    -- Make sure to update all players, even if they don't have ESP objects yet
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            -- Create ESP for this player if it doesn't exist
            if not self.DrawingObjects[player] then
                self:CreatePlayerESP(player)
            end
        end
    end
    
    for player, esp in pairs(self.DrawingObjects) do
        if not player or not player.Parent then
            self:RemovePlayerESP(player)
            continue
        end
        
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
            esp.Name.Visible = false
            esp.Tool.Visible = false
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
            continue
        end
        
        -- Check if player is alive
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
            esp.Name.Visible = false
            esp.Tool.Visible = false
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
            continue
        end
        
        -- Team check
        if self.BoxESP.TeamCheck and player.Team == game.Players.LocalPlayer.Team then
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
            esp.Name.Visible = false
            esp.Tool.Visible = false
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
            continue
        end
        
        -- Da Hood specific checks
        if self:IsPlayerKnocked(player) or self:IsPlayerDead(player) or 
           self:IsPlayerInSameCrew(player) or self:IsPlayerGrabbed(player) or
           (self.BoxESP.CheckVisible and not self:IsPlayerVisible(player)) then
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
            esp.Name.Visible = false
            esp.Tool.Visible = false
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
            continue
        end
        
        -- Get player position
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local head = character:FindFirstChild("Head")
        
        if not rootPart or not head then
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
            esp.Name.Visible = false
            esp.Tool.Visible = false
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
            continue
        end
        
        -- Check if player is on screen
        local rootVector, rootOnScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position)
        
        if not rootOnScreen then
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
            esp.Name.Visible = false
            esp.Tool.Visible = false
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
            continue
        end
        
        -- Calculate box size to cover the avatar but make it shorter
        local topPos = game.Workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 2.5, 0))
        local bottomPos = game.Workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 2.5, 0))
        local width = math.abs(topPos.Y - bottomPos.Y) / 2
        
        local boxSize = Vector2.new(width * 1.5, width * 2.5) -- Made height shorter (2.5 instead of 3)
        local boxPosition = Vector2.new(rootVector.X - boxSize.X / 2, rootVector.Y - boxSize.Y / 2)
        
        -- Update box
        esp.Box.Size = boxSize
        esp.Box.Position = boxPosition
        esp.Box.Visible = self.Enabled and self.BoxESP.Enabled
        
        -- Update box fill
        esp.BoxFill.Size = boxSize
        esp.BoxFill.Position = boxPosition
        esp.BoxFill.Visible = self.Enabled and self.BoxESP.Enabled and self.BoxESP.BoxFill
        
        -- Update name ESP
        esp.Name.Position = Vector2.new(rootVector.X, boxPosition.Y + self.NameESP.Offset.Y)
        esp.Name.Text = self:GetPlayerName(player)
        esp.Name.Visible = self.Enabled and self.NameESP.Enabled
        
        -- Update tool ESP
        esp.Tool.Position = Vector2.new(rootVector.X, boxPosition.Y + boxSize.Y + 5)
        esp.Tool.Text = "[" .. self:GetPlayerTool(player) .. "]"
        esp.Tool.Visible = self.Enabled and self.ToolESP.Enabled
        
        -- Update health bar
        self:UpdateHealthBar(player, esp, character, boxPosition, boxSize)
        
        -- Update armor bar
        self:UpdateArmorBar(player, esp, character, boxPosition, boxSize)
        
        -- Update highlight
        self:UpdateHighlight(player, esp, character)
        
        -- Update colors
        esp.Box.Color = self.BoxESP.Color
        esp.BoxFill.Color = self.BoxESP.BoxFillColor
        esp.BoxFill.Transparency = self.BoxESP.BoxFillTransparency
        esp.Name.Color = self.NameESP.Color
        esp.Tool.Color = self.ToolESP.Color
        esp.Armorbar.Color = self.Armorbar.Color
    end
end

-- Clean up ESP when player leaves
game.Players.PlayerRemoving:Connect(function(player)
    if ESP.DrawingObjects[player] then
        for key, drawing in pairs(ESP.DrawingObjects[player]) do
            if key ~= "Highlight" and drawing.Remove then
                drawing:Remove()
            elseif key == "Highlight" and drawing then
                drawing:Destroy()
            end
        end
        ESP.DrawingObjects[player] = nil
    end
end)

-- Initialize ESP
function ESP:Init()
    -- Create ESP for existing players
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            self:CreatePlayerESP(player)
        end
    end
    
    -- Connect player added event
    game.Players.PlayerAdded:Connect(function(player)
        self:CreatePlayerESP(player)
    end)
    
    -- Connect player removing event
    game.Players.PlayerRemoving:Connect(function(player)
        self:RemovePlayerESP(player)
    end)
    
    -- Update ESP
    game:GetService("RunService").RenderStepped:Connect(function()
        self:Update()
    end)
end

-- Initialize ESP
ESP:Init()

-- Create ESP section in visuals tab
local esp_section = visuals:section({name = "ESP", side = "left"})

-- Main ESP toggle
esp_section:toggle({name = "Enable ESP", flag = "esp_enabled", default = false, callback = function(bool)
    ESP.Enabled = bool
    
    -- Make sure to hide all ESP elements when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            for key, drawing in pairs(esp) do
                if key ~= "Highlight" and drawing.Visible ~= nil then
                    drawing.Visible = false
                elseif key == "Highlight" and drawing then
                    drawing.Enabled = false
                end
            end
        end
    end
end})

-- ESP Checks dropdown
esp_section:dropdown({
    name = "ESP Checks",
    flag = "esp_checks",
    default = {"Team", "Visible", "Knocked", "Dead", "Crew", "Grabbed"},
    multi = true,
    items = {"Team", "Visible", "Knocked", "Dead", "Crew", "Grabbed"},
    callback = function(selected)
        ESP.BoxESP.TeamCheck = table.find(selected, "Team") ~= nil
        ESP.BoxESP.CheckVisible = table.find(selected, "Visible") ~= nil
        ESP.BoxESP.CheckKnocked = table.find(selected, "Knocked") ~= nil
        ESP.BoxESP.CheckDead = table.find(selected, "Dead") ~= nil
        ESP.BoxESP.CheckCrew = table.find(selected, "Crew") ~= nil
        ESP.BoxESP.CheckGrabbed = table.find(selected, "Grabbed") ~= nil
    end
})

-- Box ESP toggle
esp_section:toggle({name = "Box ESP", flag = "box_esp_enabled", default = false, callback = function(bool)
    ESP.BoxESP.Enabled = bool
    
    -- Make sure to hide all boxes when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            esp.Box.Visible = false
            esp.BoxFill.Visible = false
        end
    end
end})

-- Box color picker
esp_section:colorpicker({name = "Box Color", flag = "box_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    ESP.BoxESP.Color = color
end})

-- Box fill toggle
esp_section:toggle({name = "Box Fill", flag = "box_fill_enabled", default = false, callback = function(bool)
    ESP.BoxESP.BoxFill = bool
    
    -- Make sure to hide all box fills when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            esp.BoxFill.Visible = false
        end
    end
end})

-- Box fill color picker
esp_section:colorpicker({name = "Box Fill Color", flag = "box_fill_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    ESP.BoxESP.BoxFillColor = color
end})

-- Box fill transparency slider
esp_section:slider({name = "Box Fill Transparency", flag = "box_fill_transparency", min = 0, max = 1, default = 0.5, interval = 0.1, suffix = "", callback = function(value)
    ESP.BoxESP.BoxFillTransparency = value
end})

-- Name ESP toggle
esp_section:toggle({name = "Name ESP", flag = "name_esp_enabled", default = false, callback = function(bool)
    ESP.NameESP.Enabled = bool
    
    -- Make sure to hide all names when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            esp.Name.Visible = false
        end
    end
end})

-- Name color picker
esp_section:colorpicker({name = "Name Color", flag = "name_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    ESP.NameESP.Color = color
end})

-- Name display type dropdown
esp_section:dropdown({
    name = "Name Display Type",
    flag = "name_display_type",
    default = "Username",
    items = {"Username", "DisplayName", "Both"},
    callback = function(selected)
        ESP.NameESP.DisplayType = selected
    end
})

-- Tool ESP toggle
esp_section:toggle({name = "Tool ESP", flag = "tool_esp_enabled", default = false, callback = function(bool)
    ESP.ToolESP.Enabled = bool
    
    -- Make sure to hide all tool texts when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            esp.Tool.Visible = false
        end
    end
end})

-- Tool color picker
esp_section:colorpicker({name = "Tool Color", flag = "tool_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    ESP.ToolESP.Color = color
end})

-- Health Bar ESP toggle
esp_section:toggle({name = "Health Bar", flag = "health_bar_enabled", default = false, callback = function(bool)
    ESP.Healthbar.Enabled = bool
    
    -- Make sure to hide all health bars when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            esp.Healthbar.Visible = false
            esp.Healthbar_Outline.Visible = false
        end
    end
end})

-- Health Bar color picker
esp_section:colorpicker({name = "Health Bar Color", flag = "health_bar_color", default = Color3.fromRGB(0, 255, 0), callback = function(color)
    ESP.Healthbar.Color = color
end})

-- Health Bar Position dropdown
esp_section:dropdown({
    name = "Health Bar Position",
    flag = "health_bar_position",
    default = "Left",
    items = {"Left", "Right", "Top", "Bottom"},
    callback = function(selected)
        ESP.Healthbar.Position = selected
    end
})

-- Armor Bar ESP toggle
esp_section:toggle({name = "Armor Bar", flag = "armor_bar_enabled", default = false, callback = function(bool)
    ESP.Armorbar.Enabled = bool
    
    -- Make sure to hide all armor bars when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            esp.Armorbar.Visible = false
            esp.Armorbar_Outline.Visible = false
        end
    end
end})

-- Armor Bar color picker
esp_section:colorpicker({name = "Armor Bar Color", flag = "armor_bar_color", default = Color3.fromRGB(0, 170, 255), callback = function(color)
    ESP.Armorbar.Color = color
end})

-- Armor Bar Position dropdown
esp_section:dropdown({
    name = "Armor Bar Position",
    flag = "armor_bar_position",
    default = "Right",
    items = {"Left", "Right", "Top", "Bottom"},
    callback = function(selected)
        ESP.Armorbar.Position = selected
    end
})

-- Highlight ESP toggle
esp_section:toggle({name = "Highlight ESP", flag = "highlight_esp_enabled", default = false, callback = function(bool)
    ESP.Highlight.Enabled = bool
    
    -- Make sure to disable all highlights when disabled
    if not bool then
        for _, esp in pairs(ESP.DrawingObjects) do
            if esp.Highlight then
                esp.Highlight.Enabled = false
            end
        end
    end
end})

-- Highlight Fill color picker
esp_section:colorpicker({name = "Highlight Fill Color", flag = "highlight_fill_color", default = Color3.fromRGB(255, 0, 0), callback = function(color)
    ESP.Highlight.FillColor = color
    
    -- Update all highlights
    for _, esp in pairs(ESP.DrawingObjects) do
        if esp.Highlight then
            esp.Highlight.FillColor = color
        end
    end
end})

-- Highlight Outline color picker
esp_section:colorpicker({name = "Highlight Outline Color", flag = "highlight_outline_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    ESP.Highlight.OutlineColor = color
    
    -- Update all highlights
    for _, esp in pairs(ESP.DrawingObjects) do
        if esp.Highlight then
            esp.Highlight.OutlineColor = color
        end
    end
end})

-- Create World section
local world_section = visuals:section({name = "World", side = "right"})

-- Map Changer
world_section:dropdown({
    name = "Map Theme",
    flag = "map_theme",
    default = "Default",
    items = {"Default", "Night", "Sunset", "Morning", "Foggy", "Spooky"},
    callback = function(selected)
        local lighting = game:GetService("Lighting")
        
        if selected == "Default" then
            lighting.ClockTime = 14
            lighting.Brightness = 2
            lighting.Ambient = Color3.fromRGB(150, 150, 150)
            lighting.OutdoorAmbient = Color3.fromRGB(150, 150, 150)
            lighting.FogEnd = 100000
            lighting.FogStart = 0
        elseif selected == "Night" then
            lighting.ClockTime = 0
            lighting.Brightness = 0.25
            lighting.Ambient = Color3.fromRGB(50, 50, 80)
            lighting.OutdoorAmbient = Color3.fromRGB(50, 50, 80)
            lighting.FogEnd = 100000
            lighting.FogStart = 0
        elseif selected == "Sunset" then
            lighting.ClockTime = 17.5
            lighting.Brightness = 1
            lighting.Ambient = Color3.fromRGB(255, 180, 100)
            lighting.OutdoorAmbient = Color3.fromRGB(255, 180, 100)
            lighting.FogEnd = 100000
            lighting.FogStart = 0
        elseif selected == "Morning" then
            lighting.ClockTime = 6.5
            lighting.Brightness = 1.5
            lighting.Ambient = Color3.fromRGB(200, 200, 255)
            lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 255)
            lighting.FogEnd = 100000
            lighting.FogStart = 0
        elseif selected == "Foggy" then
            lighting.ClockTime = 14
            lighting.Brightness = 1
            lighting.Ambient = Color3.fromRGB(150, 150, 150)
            lighting.OutdoorAmbient = Color3.fromRGB(150, 150, 150)
            lighting.FogEnd = 300
            lighting.FogStart = 0
            lighting.FogColor = Color3.fromRGB(180, 180, 180)
        elseif selected == "Spooky" then
            lighting.ClockTime = 0
            lighting.Brightness = 0.5
            lighting.Ambient = Color3.fromRGB(100, 0, 0)
            lighting.OutdoorAmbient = Color3.fromRGB(100, 0, 0)
            lighting.FogEnd = 200
            lighting.FogStart = 0
            lighting.FogColor = Color3.fromRGB(100, 0, 0)
        end
    end
})

-- Light Changer
world_section:dropdown({
    name = "Light Technology",
    flag = "light_technology",
    default = "Legacy",
    items = {"Legacy", "Future", "Voxel", "Compatibility", "ShadowMap"},
    callback = function(selected)
        local lighting = game:GetService("Lighting")
        
        if selected == "Legacy" then
            lighting.Technology = Enum.Technology.Legacy
        elseif selected == "Future" then
            lighting.Technology = Enum.Technology.Future
        elseif selected == "Voxel" then
            lighting.Technology = Enum.Technology.Voxel
        elseif selected == "Compatibility" then
            lighting.Technology = Enum.Technology.Compatibility
        elseif selected == "ShadowMap" then
            lighting.Technology = Enum.Technology.ShadowMap
        end
    end
})

-- Time of Day Slider
world_section:slider({name = "Time of Day", flag = "time_of_day", min = 0, max = 24, default = 14, interval = 0.5, suffix = "", callback = function(value)
    game:GetService("Lighting").ClockTime = value
end})

-- Brightness Slider
world_section:slider({name = "Brightness", flag = "brightness", min = 0, max = 5, default = 2, interval = 0.1, suffix = "x", callback = function(value)
    game:GetService("Lighting").Brightness = value
end})

-- Global Shadows
world_section:toggle({name = "Global Shadows", flag = "global_shadows", default = true, callback = function(bool)
    game:GetService("Lighting").GlobalShadows = bool
end})

-- Shadow Softness
world_section:slider({name = "Shadow Softness", flag = "shadow_softness", min = 0, max = 1, default = 0.5, interval = 0.1, suffix = "", callback = function(value)
    game:GetService("Lighting").ShadowSoftness = value
end})

-- Exposure Compensation
world_section:slider({name = "Exposure", flag = "exposure", min = -3, max = 3, default = 0, interval = 0.1, suffix = "", callback = function(value)
    game:GetService("Lighting").ExposureCompensation = value
end})

-- Fog Changer
world_section:toggle({name = "Custom Fog", flag = "custom_fog", default = false, callback = function(bool)
    if not bool then
        game:GetService("Lighting").FogEnd = 100000
        game:GetService("Lighting").FogStart = 0
    end
end})

-- Fog Color
world_section:colorpicker({name = "Fog Color", flag = "fog_color", default = Color3.fromRGB(180, 180, 180), callback = function(color)
    game:GetService("Lighting").FogColor = color
end})

-- Fog End Distance
world_section:slider({name = "Fog End Distance", flag = "fog_end", min = 50, max = 1000, default = 300, suffix = "", callback = function(value)
    if flags.custom_fog then
        game:GetService("Lighting").FogEnd = value
    end
end})

-- Fog Start Distance
world_section:slider({name = "Fog Start Distance", flag = "fog_start", min = 0, max = 500, default = 0, suffix = "", callback = function(value)
    if flags.custom_fog then
        game:GetService("Lighting").FogStart = value
    end
end})

-- Ambience Changer
world_section:toggle({name = "Custom Ambience", flag = "custom_ambience", default = false, callback = function(bool)
    if not bool then
        game:GetService("Lighting").Ambient = Color3.fromRGB(150, 150, 150)
        game:GetService("Lighting").OutdoorAmbient = Color3.fromRGB(150, 150, 150)
    end
end})

-- Ambience Color
world_section:colorpicker({name = "Ambience Color", flag = "ambience_color", default = Color3.fromRGB(150, 150, 150), callback = function(color)
    if flags.custom_ambience then
        game:GetService("Lighting").Ambient = color
        game:GetService("Lighting").OutdoorAmbient = color
    end
end})

-- Create color correction effect
local function setupColorCorrection()
    local lighting = game:GetService("Lighting")
    local colorCorrection = lighting:FindFirstChildOfClass("ColorCorrectionEffect")
    
    if not colorCorrection then
        colorCorrection = Instance.new("ColorCorrectionEffect")
        colorCorrection.Name = "OracleColorCorrection"
        colorCorrection.Parent = lighting
    end
    
    return colorCorrection
end

-- Color correction toggle
world_section:toggle({name = "Color Correction", flag = "color_correction", default = false, callback = function(bool)
    local colorCorrection = setupColorCorrection()
    colorCorrection.Enabled = bool
end})

-- Contrast slider
world_section:slider({name = "Contrast", flag = "contrast", min = 0, max = 3, default = 1, interval = 0.1, suffix = "x", callback = function(value)
    local colorCorrection = setupColorCorrection()
    colorCorrection.Contrast = value
end})

-- Saturation slider
world_section:slider({name = "Saturation", flag = "saturation", min = -1, max = 1, default = 0, interval = 0.1, suffix = "", callback = function(value)
    local colorCorrection = setupColorCorrection()
    colorCorrection.Saturation = value
end})

-- Tint color
world_section:colorpicker({name = "Tint Color", flag = "tint_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    local colorCorrection = setupColorCorrection()
    colorCorrection.TintColor = color
end})

-- Create CamLock module locally
local CamLock = {
    Enabled = false,
    Target = nil,
    Settings = {
        Smoothness = 0.5,
        PredictionAmount = 0.15,
        AimPart = "HumanoidRootPart",
        FOV = 250,
        ShowFOV = true,
        FOVColor = Color3.fromRGB(255, 255, 255),
        MaxDistance = 500,
        TeamCheck = false,
        UsePrediction = true,
        UseSmoothing = true,
        -- Shake settings
        UseShake = false,
        ShakeAxes = {"X", "Y"},
        ShakeX = 5,
        ShakeY = 5,
        ShakeZ = 0,
        -- Checks
        CheckKnocked = true,
        CheckDead = true,
        CheckForcefield = true,
        CheckWalls = true
    },
    FOVCircle = Drawing.new("Circle")
}

-- Initialize FOV circle
CamLock.FOVCircle.Visible = false
CamLock.FOVCircle.Radius = CamLock.Settings.FOV
CamLock.FOVCircle.Color = CamLock.Settings.FOVColor
CamLock.FOVCircle.Thickness = 1
CamLock.FOVCircle.Filled = false
CamLock.FOVCircle.Transparency = 1

-- Update FOV circle position
game:GetService("RunService").RenderStepped:Connect(function()
    if CamLock.Settings.ShowFOV then
        CamLock.FOVCircle.Visible = true
        CamLock.FOVCircle.Position = Vector2.new(game:GetService("UserInputService"):GetMouseLocation().X, game:GetService("UserInputService"):GetMouseLocation().Y)
        CamLock.FOVCircle.Radius = CamLock.Settings.FOV
        CamLock.FOVCircle.Color = CamLock.Settings.FOVColor
    else
        CamLock.FOVCircle.Visible = false
    end
end)

-- Function to check if a player is within FOV
function CamLock:IsInFOV(player)
    local character = player.Character
    if not character or not character:FindFirstChild(self.Settings.AimPart) then return false end
    
    local screenPoint = game.Workspace.CurrentCamera:WorldToScreenPoint(character[self.Settings.AimPart].Position)
    local vector, onScreen = Vector2.new(screenPoint.X, screenPoint.Y), screenPoint.Z > 0
    
    if not onScreen then return false end
    
    local mousePos = game:GetService("UserInputService"):GetMouseLocation()
    local distance = (mousePos - vector).Magnitude
    
    return distance <= self.Settings.FOV
end

-- Function to check if a player is knocked (Da Hood specific)
function CamLock:IsPlayerKnocked(player)
    if not self.Settings.CheckKnocked then return false end
    
    local character = player.Character
    if not character then return true end
    
    -- Da Hood specific check for knocked state
    if character:FindFirstChild("BodyEffects") and 
       character.BodyEffects:FindFirstChild("K.O") and 
       character.BodyEffects["K.O"].Value then
        return true
    end
    
    return false
end

-- Function to check if a player is dead (Da Hood specific)
function CamLock:IsPlayerDead(player)
    if not self.Settings.CheckDead then return false end
    
    local character = player.Character
    if not character then return true end
    
    -- Check if humanoid exists and health is 0
    if character:FindFirstChild("Humanoid") and character.Humanoid.Health <= 0 then
        return true
    end
    
    return false
end

-- Function to check if a player has forcefield
function CamLock:HasForcefield(player)
    if not self.Settings.CheckForcefield then return false end
    
    local character = player.Character
    if not character then return true end
    
    -- Check for forcefield
    if character:FindFirstChild("ForceField") then
        return true
    end
    
    return false
end

-- Function to check if there's a wall between player and target
function CamLock:IsWallBetween(player)
    if not self.Settings.CheckWalls then return false end
    
    local character = player.Character
    if not character or not character:FindFirstChild(self.Settings.AimPart) then return true end
    
    local rayOrigin = game.Workspace.CurrentCamera.CFrame.Position
    local rayDirection = (character[self.Settings.AimPart].Position - rayOrigin).Unit
    local rayDistance = (character[self.Settings.AimPart].Position - rayOrigin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character, character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = game.Workspace:Raycast(rayOrigin, rayDirection * rayDistance, raycastParams)
    
    return raycastResult ~= nil
end

-- Function to check if a player passes all checks
function CamLock:PassesChecks(player)
    if self:IsPlayerKnocked(player) then return false end
    if self:IsPlayerDead(player) then return false end
    if self:HasForcefield(player) then return false end
    if self:IsWallBetween(player) then return false end
    
    return true
end

-- Function to get closest player to mouse
function CamLock:GetClosestPlayerToMouse()
    local closestPlayer = nil
    local shortestDistance = self.Settings.FOV
    
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            -- Team check
            if self.Settings.TeamCheck and player.Team == game:GetService("Players").LocalPlayer.Team then
                continue
            end
            
            local character = player.Character
            if character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 and character:FindFirstChild(self.Settings.AimPart) then
                -- Check all conditions
                if not self:PassesChecks(player) then
                    continue
                end
                
                local pos = game.Workspace.CurrentCamera:WorldToScreenPoint(character[self.Settings.AimPart].Position)
                local magnitude = (Vector2.new(pos.X, pos.Y) - game:GetService("UserInputService"):GetMouseLocation()).Magnitude
                
                if magnitude < shortestDistance and self:IsInFOV(player) then
                    closestPlayer = player
                    shortestDistance = magnitude
                end
            end
        end
    end
    
    return closestPlayer
end

-- Toggle camlock
function CamLock:Toggle()
    self.Enabled = not self.Enabled
    if not self.Enabled then
        self.Target = nil
    else
        self.Target = self:GetClosestPlayerToMouse()
    end
    return self.Enabled
end

-- Set target
function CamLock:SetTarget(player)
    self.Target = player
end

-- Generate random shake offset
function CamLock:GetShakeOffset()
    local offset = Vector3.new(0, 0, 0)
    
    if not self.Settings.UseShake then
        return offset
    end
    
    for _, axis in pairs(self.Settings.ShakeAxes) do
        if axis == "X" then
            offset = offset + Vector3.new(math.random(-self.Settings.ShakeX, self.Settings.ShakeX) / 100, 0, 0)
        elseif axis == "Y" then
            offset = offset + Vector3.new(0, math.random(-self.Settings.ShakeY, self.Settings.ShakeY) / 100, 0)
        elseif axis == "Z" then
            offset = offset + Vector3.new(0, 0, math.random(-self.Settings.ShakeZ, self.Settings.ShakeZ) / 100)
        end
    end
    
    return offset
end

-- Main camlock function
local camlockConnection = game:GetService("RunService").RenderStepped:Connect(function()
    -- Only run if CamLock is enabled
    if not CamLock.Enabled then
        return
    end
    
    if CamLock.Target and CamLock.Target.Character and CamLock.Target.Character:FindFirstChild(CamLock.Settings.AimPart) then
        local character = CamLock.Target.Character
        local targetPart = character[CamLock.Settings.AimPart]
        
        -- Check if target still passes all checks
        if not CamLock:PassesChecks(CamLock.Target) then
            CamLock.Target = nil
            return
        end
        
        -- Check distance
        local distance = (character:FindFirstChild("HumanoidRootPart").Position - game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if distance > CamLock.Settings.MaxDistance then
            CamLock.Target = nil
            return
        end
        
        -- Calculate target position
        local targetPosition = targetPart.Position
        local finalPosition = targetPosition
        
        -- Apply prediction if enabled
        if CamLock.Settings.UsePrediction then
            local targetVelocity = targetPart.Velocity
            local predictionOffset = targetVelocity * CamLock.Settings.PredictionAmount
            finalPosition = targetPosition + predictionOffset
        end
        
        -- Apply shake
        local shakeOffset = CamLock:GetShakeOffset()
        finalPosition = finalPosition + shakeOffset
        
        -- Calculate camera movement
        local camera = game.Workspace.CurrentCamera
        local cameraPosition = camera.CFrame.Position
        local targetCFrame = CFrame.new(cameraPosition, finalPosition)
        
        -- Apply smoothness if enabled
        if CamLock.Settings.UseSmoothing then
            camera.CFrame = camera.CFrame:Lerp(targetCFrame, CamLock.Settings.Smoothness)
        else
            camera.CFrame = targetCFrame
        end
    end
end)

-- Create CamLock section
local camlock_section = legit:section({name = "Camera Lock", side = "left"})

-- Main toggles
camlock_section:toggle({name = "Enabled", flag = "camlock_enabled", default = false, callback = function(bool)
    CamLock.Enabled = bool
    if not bool then
        CamLock.Target = nil
    end
    -- Don't automatically set target when enabled, let user press the keybind
end})

camlock_section:toggle({name = "Show FOV", flag = "camlock_show_fov", default = false, callback = function(bool)
    CamLock.Settings.ShowFOV = bool
end})

camlock_section:toggle({name = "Team Check", flag = "camlock_team_check", default = false, callback = function(bool)
    CamLock.Settings.TeamCheck = bool
end})

camlock_section:toggle({name = "Use Prediction", flag = "camlock_use_prediction", default = false, callback = function(bool)
    CamLock.Settings.UsePrediction = bool
end})

camlock_section:toggle({name = "Use Shake", flag = "camlock_use_shake", default = false, callback = function(bool)
    CamLock.Settings.UseShake = bool
end})

camlock_section:toggle({name = "Use Smoothing", flag = "camlock_use_smoothing", default = false, callback = function(bool)
    CamLock.Settings.UseSmoothing = bool
end})

-- Sliders
camlock_section:slider({name = "FOV Size", flag = "camlock_fov", min = 50, max = 500, default = 250, interval = 1, suffix = "px", callback = function(value)
    CamLock.Settings.FOV = value
end})

camlock_section:slider({name = "Max Distance", flag = "camlock_max_distance", min = 100, max = 1000, default = 500, interval = 10, suffix = "", callback = function(value)
    CamLock.Settings.MaxDistance = value
end})

camlock_section:slider({name = "Prediction", flag = "camlock_prediction", min = 0, max = 0.5, default = 0.15, interval = 0.01, suffix = "", callback = function(value)
    CamLock.Settings.PredictionAmount = value
end})

camlock_section:slider({name = "Smoothness", flag = "camlock_smoothness", min = 0, max = 1, default = 0.5, interval = 0.01, suffix = "", callback = function(value)
    CamLock.Settings.Smoothness = value
end})

-- Dropdown for aim part
camlock_section:dropdown({name = "Aim Part", flag = "camlock_aim_part", default = "HumanoidRootPart", items = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, callback = function(part)
    CamLock.Settings.AimPart = part
end})

-- Keybind for toggling camlock
camlock_section:keybind({name = "Toggle Key", flag = "camlock_toggle_key", callback = function(key)
    if library.flags.camlock_enabled then
        if CamLock.Target then
            CamLock.Target = nil
        else
            CamLock.Target = CamLock:GetClosestPlayerToMouse()
        end
    end
end})

-- Color picker for FOV
camlock_section:colorpicker({name = "FOV Color", flag = "camlock_fov_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    CamLock.Settings.FOVColor = color
end})

-- Checks section
local checks_section = legit:section({name = "Target Checks", side = "right"})

checks_section:toggle({name = "Check Dead", flag = "camlock_check_dead", default = false, callback = function(bool)
    CamLock.Settings.CheckDead = bool
end})

checks_section:toggle({name = "Check Forcefield", flag = "camlock_check_forcefield", default = false, callback = function(bool)
    CamLock.Settings.CheckForcefield = bool
end})

checks_section:toggle({name = "Check Knocked", flag = "camlock_check_knocked", default = false, callback = function(bool)
    CamLock.Settings.CheckKnocked = bool
end})

checks_section:toggle({name = "Wall Check", flag = "camlock_check_walls", default = false, callback = function(bool)
    CamLock.Settings.CheckWalls = bool
end})

-- Shake settings
local shake_section = legit:section({name = "Shake Settings", side = "right"})

shake_section:slider({name = "Shake X", flag = "camlock_shake_x", min = 0, max = 50, default = 5, interval = 1, suffix = "", callback = function(value)
    CamLock.Settings.ShakeX = value
end})

shake_section:slider({name = "Shake Y", flag = "camlock_shake_y", min = 0, max = 50, default = 5, interval = 1, suffix = "", callback = function(value)
    CamLock.Settings.ShakeY = value
end})

shake_section:slider({name = "Shake Z", flag = "camlock_shake_z", min = 0, max = 50, default = 0, interval = 1, suffix = "", callback = function(value)
    CamLock.Settings.ShakeZ = value
end})

-- Shake axes selection (using multiple toggles instead of multiselect)
shake_section:toggle({name = "Shake X Axis", flag = "camlock_shake_x_axis", default = false, callback = function(bool)
    local axes = {}
    if bool then table.insert(axes, "X") end
    if library.flags.camlock_shake_y_axis then table.insert(axes, "Y") end
    if library.flags.camlock_shake_z_axis then table.insert(axes, "Z") end
    CamLock.Settings.ShakeAxes = axes
end})

shake_section:toggle({name = "Shake Y Axis", flag = "camlock_shake_y_axis", default = false, callback = function(bool)
    local axes = {}
    if library.flags.camlock_shake_x_axis then table.insert(axes, "X") end
    if bool then table.insert(axes, "Y") end
    if library.flags.camlock_shake_z_axis then table.insert(axes, "Z") end
    CamLock.Settings.ShakeAxes = axes
end})

shake_section:toggle({name = "Shake Z Axis", flag = "camlock_shake_z_axis", default = false, callback = function(bool)
    local axes = {}
    if library.flags.camlock_shake_x_axis then table.insert(axes, "X") end
    if library.flags.camlock_shake_y_axis then table.insert(axes, "Y") end
    if bool then table.insert(axes, "Z") end
    CamLock.Settings.ShakeAxes = axes
end})

-- Hitbox Expander for Da Hood
local HitboxExpander = {
    Enabled = false,
    Size = 25,
    RefreshTime = 0.5,
    Color = Color3.fromRGB(255, 0, 0),
    Transparency = 0.5,
    Material = Enum.Material.ForceField,
    TeamCheck = false
}

-- Create Hitbox Expander section
local hitbox_section = legit:section({name = "Hitbox Expander", side = "left"})

-- Main toggle
hitbox_section:toggle({name = "Enabled", flag = "hitbox_enabled", default = false, callback = function(bool)
    HitboxExpander.Enabled = bool
    
    -- Start or stop the hitbox expander loop
    if bool then
        -- Create a new thread for the hitbox expander
        spawn(function()
            while HitboxExpander.Enabled do
                for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                    if player.UserId ~= game:GetService("Players").LocalPlayer.UserId then
                        -- Team check
                        if HitboxExpander.TeamCheck and player.Team == game:GetService("Players").LocalPlayer.Team then
                            continue
                        end
                        
                        -- Check if player has a character and humanoid
                        if player.Character and 
                           player.Character:FindFirstChildOfClass("Humanoid") and 
                           player.Character:FindFirstChildOfClass("Humanoid").RootPart then
                            
                            -- Check for Da Hood knocked state
                            if player.Character:FindFirstChild("BodyEffects") and 
                               player.Character.BodyEffects:FindFirstChild("K.O") and 
                               player.Character.BodyEffects["K.O"].Value then
                                continue
                            end
                            
                            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                            local rootPart = humanoid.RootPart
                            
                            -- Apply hitbox modifications
                            rootPart.CanCollide = false
                            rootPart.Size = Vector3.new(HitboxExpander.Size, HitboxExpander.Size, HitboxExpander.Size)
                            rootPart.Transparency = HitboxExpander.Transparency
                            rootPart.Color = HitboxExpander.Color
                            rootPart.Material = HitboxExpander.Material
                        end
                    end
                end
                task.wait(HitboxExpander.RefreshTime)
            end
            
            -- Reset hitboxes when disabled
            for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                if player.UserId ~= game:GetService("Players").LocalPlayer.UserId and 
                   player.Character and 
                   player.Character:FindFirstChildOfClass("Humanoid") and 
                   player.Character:FindFirstChildOfClass("Humanoid").RootPart then
                    
                    local rootPart = player.Character:FindFirstChildOfClass("Humanoid").RootPart
                    rootPart.Size = Vector3.new(2, 2, 1) -- Default size
                    rootPart.Transparency = 1
                    rootPart.Material = Enum.Material.Plastic
                end
            end
        end)
    end
end})

-- Team check toggle
hitbox_section:toggle({name = "Team Check", flag = "hitbox_team_check", default = false, callback = function(bool)
    HitboxExpander.TeamCheck = bool
end})

-- Size slider
hitbox_section:slider({name = "Hitbox Size", flag = "hitbox_size", min = 5, max = 50, default = 25, interval = 1, suffix = "", callback = function(value)
    HitboxExpander.Size = value
end})

-- Refresh time slider
hitbox_section:slider({name = "Refresh Rate", flag = "hitbox_refresh", min = 0.1, max = 5, default = 0.5, interval = 0.1, suffix = "s", callback = function(value)
    HitboxExpander.RefreshTime = value
end})

-- Transparency slider
hitbox_section:slider({name = "Transparency", flag = "hitbox_transparency", min = 0, max = 1, default = 0.5, interval = 0.05, suffix = "", callback = function(value)
    HitboxExpander.Transparency = value
end})

-- Color picker
hitbox_section:colorpicker({name = "Hitbox Color", flag = "hitbox_color", default = Color3.fromRGB(255, 0, 0), callback = function(color)
    HitboxExpander.Color = color
end})

-- Material dropdown
hitbox_section:dropdown({name = "Hitbox Material", flag = "hitbox_material", default = "ForceField", items = {
    "ForceField", "Neon", "Glass", "SmoothPlastic", "Plastic", "Metal"
}, callback = function(material)
    local materials = {
        ForceField = Enum.Material.ForceField,
        Neon = Enum.Material.Neon,
        Glass = Enum.Material.Glass,
        SmoothPlastic = Enum.Material.SmoothPlastic,
        Plastic = Enum.Material.Plastic,
        Metal = Enum.Material.Metal
    }
    
    HitboxExpander.Material = materials[material]
end})

-- Create Miscellaneous tab
local misc = window:tab({name = "miscellaneous"})

-- Create Movement section
local movement_section = misc:section({name = "Movement", side = "left"})

-- Create Game section
local game_section = misc:section({name = "Game", side = "right"})

-- Create Local Player section
local local_player_section = misc:section({name = "Local Player", side = "right"})

-- Initialize global variables if they don't exist
getgenv().walkSpeedEnabled = getgenv().walkSpeedEnabled or false
getgenv().walkSpeed = getgenv().walkSpeed or 16
getgenv().walkSpeedKeybindActive = getgenv().walkSpeedKeybindActive or false

getgenv().jumpPowerEnabled = getgenv().jumpPowerEnabled or false
getgenv().jumpPower = getgenv().jumpPower or 50
getgenv().infiniteJumpEnabled = getgenv().infiniteJumpEnabled or false

getgenv().cframeSpeedEnabled = getgenv().cframeSpeedEnabled or false
getgenv().cframeSpeed = getgenv().cframeSpeed or 2
getgenv().cframeSpeedKeybindActive = getgenv().cframeSpeedKeybindActive or false

getgenv().noclipEnabled = getgenv().noclipEnabled or false
getgenv().noSlowdownEnabled = getgenv().noSlowdownEnabled or false
getgenv().noJumpCooldownEnabled = getgenv().noJumpCooldownEnabled or false

-- Anti Stomp variables
getgenv().antiStompActive = getgenv().antiStompActive or false
getgenv().antiStompMode = getgenv().antiStompMode or "Static"
getgenv().flashbackActive = getgenv().flashbackActive or false
getgenv().lastPosition = getgenv().lastPosition or nil

-- Fly variables
getgenv().Flying = getgenv().Flying or false
getgenv().FlySpeed = getgenv().FlySpeed or 50
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = game:GetService("Players").LocalPlayer

-- Local Player section features
-- Anti Bag toggle
local_player_section:toggle({name = "Anti Bag", flag = "anti_bag", default = false, callback = function(state)
    if state then
        local function removeBag(character)
            for i, v in ipairs(character:GetDescendants()) do
                if v.Name == "Christmas_Sock" then 
                    v:Destroy()
                end
            end
        end
        
        -- Remove existing bag
        if LocalPlayer.Character then
            removeBag(LocalPlayer.Character)
        end
        
        -- Connect to ChildAdded to remove future bags
        bagConnection = LocalPlayer.Character.ChildAdded:Connect(function()
            wait(0.5)
            removeBag(LocalPlayer.Character)
        end)
        
        -- Handle character respawns
        charConnection = LocalPlayer.CharacterAdded:Connect(function(newChar)
            removeBag(newChar)
            
            bagConnection = newChar.ChildAdded:Connect(function()
                wait(0.5)
                removeBag(newChar)
            end)
        end)
    else
        if bagConnection then
            bagConnection:Disconnect()
            bagConnection = nil
        end
        
        if charConnection then
            charConnection:Disconnect()
            charConnection = nil
        end
    end
end})

-- Anti Stomp toggle
local_player_section:toggle({name = "Anti Stomp", flag = "anti_stomp", default = false, callback = function(state)
    getgenv().antiStompActive = state
    
    if state then
        local function checkAndKill()
            local chr = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hum = chr:WaitForChild("Humanoid", 5)
            local bodyEffects = chr:WaitForChild("BodyEffects", 5)

            if not bodyEffects or not hum then
                warn("BodyEffects or Humanoid not found in the character!")
                return
            end

            local koValue = bodyEffects:WaitForChild("K.O", 5)
            if not koValue then
                warn("K.O value not found!")
                return
            end

            local connection
            connection = RunService.Heartbeat:Connect(function()
                if not antiStompActive then
                    connection:Disconnect()
                    return
                end

                if koValue.Value == true and hum.Health > 0 then
                    if getgenv().antiStompMode == "Fling" then
                        lastPosition = chr:GetPrimaryPartCFrame()
                    end
                    hum.Health = 0
                end
            end)
        end

        checkAndKill()

        LocalPlayer.CharacterAdded:Connect(function(newCharacter)
            if antiStompActive then
                checkAndKill()

                if getgenv().antiStompMode == "Fling" and lastPosition then
                    local rootPart = newCharacter:WaitForChild("HumanoidRootPart", 5)
                    if rootPart then
                        while (rootPart.Position - lastPosition.Position).Magnitude > 5 do
                            rootPart.CFrame = lastPosition
                            task.wait()
                        end
                    end
                    lastPosition = nil
                end
            end
        end)
    end
end})

-- Anti Stomp Mode dropdown
local_player_section:dropdown({name = "Anti Stomp Mode", flag = "anti_stomp_mode", default = "Static", items = {
    "Static", "Fling"
}, callback = function(mode)
    getgenv().antiStompMode = mode
end})

-- Anti Fling toggle
local_player_section:toggle({name = "Anti Fling", flag = "anti_fling", default = false, callback = function(state)
    if state then
        antifling = game:GetService("RunService").Stepped:Connect(function()
            for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                if player ~= game.Players.LocalPlayer and player.Character then
                    for _, v in pairs(player.Character:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.CanCollide = false
                        end
                    end
                end
            end
        end)
    else
        if antifling then
            antifling:Disconnect()
            antifling = nil
        end
    end
end})

-- Game section features
-- Unlock Animation Pack button
game_section:button({name = "Unlock Animation Pack", callback = function()
    -- Clear existing animations
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Lean") then
        game.ReplicatedStorage.ClientAnimations.Lean:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Lay") then
        game.ReplicatedStorage.ClientAnimations.Lay:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Dance1") then
        game.ReplicatedStorage.ClientAnimations.Dance1:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Dance2") then
        game.ReplicatedStorage.ClientAnimations.Dance2:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Greet") then
        game.ReplicatedStorage.ClientAnimations.Greet:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Chest Pump") then
        game.ReplicatedStorage.ClientAnimations["Chest Pump"]:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Praying") then
        game.ReplicatedStorage.ClientAnimations.Praying:Destroy()
    end
    
    -- Create new animations
    local Animations = game.ReplicatedStorage.ClientAnimations
    
    local LeanAnimation = Instance.new("Animation", Animations)
    LeanAnimation.Name = "Lean"
    LeanAnimation.AnimationId = "rbxassetid://3152375249"
    
    local LayAnimation = Instance.new("Animation", Animations)
    LayAnimation.Name = "Lay"
    LayAnimation.AnimationId = "rbxassetid://3152378852"
    
    local Dance1Animation = Instance.new("Animation", Animations)
    Dance1Animation.Name = "Dance1"
    Dance1Animation.AnimationId = "rbxassetid://3189773368"
    
    local Dance2Animation = Instance.new("Animation", Animations)
    Dance2Animation.Name = "Dance2"
    Dance2Animation.AnimationId = "rbxassetid://3189776546"
    
    local GreetAnimation = Instance.new("Animation", Animations)
    GreetAnimation.Name = "Greet"
    GreetAnimation.AnimationId = "rbxassetid://3189777795"
    
    local ChestPumpAnimation = Instance.new("Animation", Animations)
    ChestPumpAnimation.Name = "Chest Pump"
    ChestPumpAnimation.AnimationId = "rbxassetid://3189779152"
    
    local PrayingAnimation = Instance.new("Animation", Animations)
    PrayingAnimation.Name = "Praying"
    PrayingAnimation.AnimationId = "rbxassetid://3487719500"
    
    -- Notification
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animation Pack",
        Text = "Successfully unlocked all animations!",
        Duration = 5
    })
end})

-- Force Reset button
game_section:button({name = "Force Reset", callback = function()
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Health = 0
        else
            character:BreakJoints()
        end
        
        -- Alternative method for Da Hood specifically
        local bodyEffects = character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local dead = bodyEffects:FindFirstChild("Dead")
            if dead then
                dead.Value = true
            end
        end
    end
end})

-- Chat Spy button
game_section:button({name = "Chat Spy", callback = function()
    local StarterGui = game:GetService("StarterGui")
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() or Players.LocalPlayer
    local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
    local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
    
    -- Enable chat
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
    
    -- Force chat to appear
    local chatFrame = player.PlayerGui.Chat.Frame
    chatFrame.ChatChannelParentFrame.Visible = true
    chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
    
    -- Notification
    StarterGui:SetCore("SendNotification", {
        Title = "Chat Spy Enabled",
        Text = "Now spying on all chat messages",
        Duration = 5
    })
end})

-- No Slowdown (Da Hood)
movement_section:toggle({name = "No Slowdown", flag = "no_slowdown_enabled", default = false, callback = function(bool)
    getgenv().noSlowdownEnabled = bool
    
    if bool then
        -- Hook the function that causes slowdown in Da Hood
        local mt = getrawmetatable(game)
        local oldIndex = mt.__index
        setreadonly(mt, false)
        
        mt.__index = newcclosure(function(self, key)
            if getgenv().noSlowdownEnabled and key == "WalkSpeed" and self:IsA("Humanoid") then
                return 16 -- Return default walkspeed instead of slowed value
            end
            return oldIndex(self, key)
        end)
    end
end})

-- No Jump Cooldown (Da Hood)
movement_section:toggle({name = "No Jump Cooldown", flag = "no_jump_cooldown_enabled", default = false, callback = function(bool)
    getgenv().noJumpCooldownEnabled = bool
    
    if bool then
        -- Connect to RenderStepped to constantly reset jump power
        RunService.RenderStepped:Connect(function()
            if not getgenv().noJumpCooldownEnabled then return end
            
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                -- Remove jump cooldown by setting these properties
                character.Humanoid.JumpPower = getgenv().jumpPowerEnabled and getgenv().jumpPower or 50
                character.Humanoid.UseJumpPower = true
                -- Some games use this property for jump cooldown
                if character.Humanoid:FindFirstChild("JumpCooldown") then
                    character.Humanoid.JumpCooldown.Value = 0
                end
            end
        end)
    end
end})

-- Jump Power
movement_section:toggle({name = "Jump Power", flag = "jump_power_enabled", default = false, callback = function(bool)
    getgenv().jumpPowerEnabled = bool
    
    if bool then
        local function updateJumpPower()
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.JumpPower = getgenv().jumpPower
            end
        end
        
        updateJumpPower()
        LocalPlayer.CharacterAdded:Connect(updateJumpPower)
    else
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.JumpPower = 50 -- Default jump power
        end
    end
end})

movement_section:slider({name = "Jump Power Value", flag = "jump_power_value", min = 50, max = 250, default = 50, interval = 1, suffix = "", callback = function(value)
    getgenv().jumpPower = value
    
    if getgenv().jumpPowerEnabled then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.JumpPower = value
        end
    end
end})

-- Infinite Jump
movement_section:toggle({name = "Infinite Jump", flag = "infinite_jump_enabled", default = false, callback = function(bool)
    getgenv().infiniteJumpEnabled = bool
end})

-- Connect infinite jump to UserInputService
UserInputService.JumpRequest:Connect(function()
    if getgenv().infiniteJumpEnabled then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

-- Noclip
local noclipConnection = nil
movement_section:toggle({name = "Noclip", flag = "noclip_enabled", default = false, callback = function(bool)
    getgenv().noclipEnabled = bool
    
    if bool then
        if noclipConnection then noclipConnection:Disconnect() end
        
        noclipConnection = RunService.Stepped:Connect(function()
            if not getgenv().noclipEnabled then return end
            
            local character = LocalPlayer.Character
            if not character then return end
            
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
            
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
end})

movement_section:keybind({name = "Noclip Keybind", default = Enum.KeyCode.V, mode = "toggle", callback = function(bool)
    getgenv().noclipEnabled = bool
    
    if bool then
        if noclipConnection then noclipConnection:Disconnect() end
        
        noclipConnection = RunService.Stepped:Connect(function()
            if not getgenv().noclipEnabled then return end
            
            local character = LocalPlayer.Character
            if not character then return end
            
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
            
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
end})

-- Spinbot section removed

-- CFrame Speed (Anti-Detection for Da Hood)
movement_section:toggle({name = "CFrame Speed", flag = "cframe_speed_enabled", default = false, callback = function(bool)
    getgenv().cframeSpeedEnabled = bool
    
    -- Reset position tracking when toggling
    getgenv().lastCFramePosition = nil
    getgenv().lastCFrameUpdateTime = tick()
    getgenv().cframeSpeedActive = bool
    
    -- Start a background thread to keep position updated even when not moving
    if bool then
        task.spawn(function()
            while getgenv().cframeSpeedEnabled do
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    -- Update position every 0.25 seconds for more responsive tracking
                    getgenv().lastCFramePosition = character.HumanoidRootPart.Position
                    getgenv().lastCFrameUpdateTime = tick()
                end
                task.wait(0.25) -- More frequent updates for better responsiveness
            end
        end)
    end
end})

movement_section:slider({name = "CFrame Speed Value", flag = "cframe_speed_value", min = 0.5, max = 150, default = 5, interval = 0.5, suffix = "x", callback = function(value)
    getgenv().cframeSpeed = value
end})

movement_section:keybind({name = "CFrame Speed Keybind", default = Enum.KeyCode.LeftShift, mode = "hold", callback = function(bool)
    getgenv().cframeSpeedKeybindActive = bool
    
    -- When activating the keybind, immediately update the position
    if bool then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            getgenv().lastCFramePosition = character.HumanoidRootPart.Position
            getgenv().lastCFrameUpdateTime = tick()
            getgenv().cframeSpeedActive = true
        end
    else
        getgenv().cframeSpeedActive = false
    end
end})

-- Advanced options for CFrame Speed
movement_section:toggle({name = "Adaptive Speed", flag = "cframe_adaptive_speed", default = true, callback = function(bool)
    getgenv().adaptiveSpeed = bool
end})

movement_section:toggle({name = "Bypass Walls", flag = "cframe_bypass_walls", default = true, callback = function(bool)
    getgenv().bypassWalls = bool
end})

movement_section:dropdown({name = "CFrame Mode", flag = "cframe_mode", default = "Advanced", items = {
    "Basic", "Advanced", "Extreme"
}, callback = function(mode)
    getgenv().cframeMode = mode
end})

-- Start the CFrame speed loop with improved performance and anti-detection measures
task.spawn(function()
    -- Create a table to store optimized movement patterns for variation
    local movementPatterns = {}
    for i = 1, 15 do
        table.insert(movementPatterns, {
            delay = 0.002 + (i * 0.0003), -- Faster delays
            offset = Vector3.new(math.random(-5, 5) / 100, math.random(-2, 2) / 100, math.random(-5, 5) / 100)
        })
    end
    
    -- Function to check if we're about to hit a wall with improved accuracy
    local function willHitWall(character, direction, distance)
        if not character or not character:FindFirstChild("HumanoidRootPart") or not getgenv().bypassWalls then 
            return false 
        end
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local rayOrigin = character.HumanoidRootPart.Position
        local rayResult = workspace:Raycast(rayOrigin, direction * (distance + 0.5), raycastParams)
        
        return rayResult ~= nil
    end
    
    -- Function to get a safe movement vector with improved wall detection
    local function getSafeMovement(character, moveDir, speed)
        local baseMovement = moveDir * speed
        
        -- Check if we'll hit a wall
        if willHitWall(character, moveDir, speed) then
            -- Try different directions with more options
            local alternateDirections = {
                moveDir + Vector3.new(0, 0.2, 0),
                moveDir + Vector3.new(0.2, 0, 0),
                moveDir + Vector3.new(0, 0, 0.2),
                moveDir + Vector3.new(-0.2, 0, 0),
                moveDir + Vector3.new(0, 0, -0.2),
                moveDir + Vector3.new(0.1, 0.1, 0),
                moveDir + Vector3.new(0, 0.1, 0.1),
                moveDir + Vector3.new(0.1, 0, 0.1)
            }
            
            for _, dir in ipairs(alternateDirections) do
                if not willHitWall(character, dir.Unit, speed) then
                    return dir.Unit * speed
                end
            end
            
            -- If all directions would hit a wall, move up more significantly
            return Vector3.new(0, 1, 0)
        end
        
        return baseMovement
    end
    
    -- Main CFrame speed loop with improved performance
    while true do
        if getgenv().cframeSpeedEnabled and getgenv().cframeSpeedKeybindActive then
            local character = LocalPlayer.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if character and humanoid and rootPart and humanoid.Health > 0 then
                -- Initialize position tracking if needed
                if not getgenv().lastCFramePosition then
                    getgenv().lastCFramePosition = rootPart.Position
                    getgenv().lastCFrameUpdateTime = tick()
                    getgenv().cframeSpeedActive = true
                end
                
                -- Check if we're moving
                if humanoid.MoveDirection.Magnitude > 0 then
                    -- Get current time and calculate time since last update
                    local currentTime = tick()
                    local timeSinceLastUpdate = currentTime - getgenv().lastCFrameUpdateTime
                    
                    -- Choose a random movement pattern for variation
                    local pattern = movementPatterns[math.random(1, #movementPatterns)]
                    
                    -- Calculate movement with optimized variations
                    local moveDir = humanoid.MoveDirection.Unit
                    
                    -- Apply speed based on selected mode
                    local speedMultiplier = getgenv().cframeSpeed
                    if getgenv().cframeMode == "Advanced" then
                        speedMultiplier = speedMultiplier * 1.5
                    elseif getgenv().cframeMode == "Extreme" then
                        speedMultiplier = speedMultiplier * 2.5
                    end
                    
                    -- Apply adaptive speed if enabled
                    if getgenv().adaptiveSpeed then
                        -- Increase speed when moving in the same direction for a while
                        local directionConsistency = (rootPart.Position - getgenv().lastCFramePosition).Unit:Dot(moveDir)
                        if directionConsistency > 0.8 then
                            speedMultiplier = speedMultiplier * (1 + directionConsistency * 0.5)
                        end
                    end
                    
                    -- Add small random offsets to movement direction to make it look more natural
                    moveDir = (moveDir + pattern.offset).Unit
                    
                    -- Get safe movement that won't hit walls
                    local movement = getSafeMovement(character, moveDir, speedMultiplier)
                    
                    -- Calculate maximum safe distance based on time since last update
                    local maxDistance = math.min(10, 2 + timeSinceLastUpdate * 5)
                    if movement.Magnitude > maxDistance then
                        movement = movement.Unit * maxDistance
                    end
                    
                    -- Apply the movement in small increments to avoid detection
                    local steps = getgenv().cframeMode == "Basic" and 2 or (getgenv().cframeMode == "Advanced" and 3 or 5)
                    for i = 1, steps do
                        -- Calculate position for this step
                        local stepPosition = rootPart.Position + (movement * (i / steps))
                        
                        -- Apply the movement
                        rootPart.CFrame = CFrame.new(stepPosition, stepPosition + rootPart.CFrame.LookVector)
                        
                        -- Small wait between steps
                        if i < steps then
                            task.wait(0.0005) -- Reduced wait time for faster movement
                        end
                    end
                    
                    -- Update tracking variables
                    getgenv().lastCFramePosition = rootPart.Position
                    getgenv().lastCFrameUpdateTime = currentTime
                    
                    -- Add a small random delay to make the movement pattern less predictable
                    task.wait(pattern.delay)
                else
                    -- If not moving, just update the position tracking
                    getgenv().lastCFramePosition = rootPart.Position
                    getgenv().lastCFrameUpdateTime = tick()
                    task.wait(0.02) -- Reduced wait time when not moving
                end
            else
                task.wait(0.05)
            end
        else
            -- When disabled, just wait a bit longer
            task.wait(0.1)
        end
    end
end)

-- Create a heartbeat connection to prevent teleporting after inactivity with improved responsiveness
RunService.Heartbeat:Connect(function()
    if getgenv().cframeSpeedEnabled then
        local character = LocalPlayer.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        local humanoid = character and character:FindFirstChild("Humanoid")
        
        if rootPart and humanoid and getgenv().lastCFramePosition then
            -- Calculate time since last update
            local timeSinceLastUpdate = tick() - getgenv().lastCFrameUpdateTime
            
            -- If it's been too long since the last update (player was inactive)
            -- and the player is now trying to move, prevent teleporting by
            -- updating the tracking position
            if timeSinceLastUpdate > 0.5 and humanoid.MoveDirection.Magnitude > 0 then
                getgenv().lastCFramePosition = rootPart.Position
                getgenv().lastCFrameUpdateTime = tick()
            end
            
            -- Add small random movements to avoid pattern detection when standing still
            if getgenv().cframeSpeedKeybindActive and humanoid.MoveDirection.Magnitude < 0.1 and math.random() < 0.05 then
                local microMovement = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10)) / 1000
                rootPart.CFrame = rootPart.CFrame + microMovement
            end
        end
    end
end)

-- Fly functions
local function CreateCore()
    if workspace:FindFirstChild("Core") then workspace.Core:Destroy() end
    local Core = Instance.new("Part")
    Core.Name = "Core"
    Core.Size = Vector3.new(0.05, 0.05, 0.05)
    Core.CanCollide = false
    Core.Transparency = 1
    Core.Parent = workspace
    local Weld = Instance.new("Weld", Core)
    Weld.Part0 = Core
    Weld.Part1 = LocalPlayer.Character.HumanoidRootPart
    Weld.C0 = CFrame.new(0, 0, 0)
    return Core
end

local function StartFly()
    if getgenv().Flying then return end
    getgenv().Flying = true
    LocalPlayer.Character:FindFirstChildOfClass("Humanoid").PlatformStand = true
    local Core = CreateCore()
    local BV = Instance.new("BodyVelocity", Core)
    BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    BV.Velocity = Vector3.zero
    local BG = Instance.new("BodyGyro", Core)
    BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    BG.P = 9e4
    BG.CFrame = Core.CFrame
    RunService.RenderStepped:Connect(function()
        if not getgenv().Flying then return end
        local camera = workspace.CurrentCamera
        local moveDirection = Vector3.zero
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDirection = moveDirection + camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDirection = moveDirection - camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDirection = moveDirection - camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDirection = moveDirection + camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveDirection = moveDirection + Vector3.new(0, 1, 0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveDirection = moveDirection - Vector3.new(0, 1, 0) end
        BV.Velocity = moveDirection * getgenv().FlySpeed
        BG.CFrame = camera.CFrame
    end)
end

local function StopFly()
    if not getgenv().Flying then return end
    getgenv().Flying = false
    LocalPlayer.Character:FindFirstChildOfClass("Humanoid").PlatformStand = false
    if workspace:FindFirstChild("Core") then workspace.Core:Destroy() end
end

-- Fly controls
movement_section:toggle({name = "Fly", flag = "fly_enabled", default = false, callback = function(bool)
    if bool then
        StartFly()
    else
        StopFly()
    end
end})

movement_section:slider({name = "Fly Speed", flag = "fly_speed_value", min = 1, max = 200, default = 50, interval = 1, suffix = "x", callback = function(value)
    getgenv().FlySpeed = value
end})

movement_section:keybind({name = "Fly Keybind", default = Enum.KeyCode.X, mode = "toggle", callback = function(bool)
    if bool then
        StartFly()
    else
        StopFly()
    end
end})


local target_aim_rage = rage_tab:section({name = "Target Aim", side = "left"})

-- Target Aim Configuration
local TargetAim = {
    Enabled = false,
    LockedTarget = nil,
    TargetPart = nil,
    HitChance = 100,
    SelectedPart = "Head",
    Prediction = {
        Enabled = true,
        Strength = 0.165
    },
    FOV = {
        Visible = true,
        Radius = 85,
        Color = Color3.fromRGB(255, 255, 255),
        Filled = false,
        Transparency = 0.5
    },
    Visualization = {
        Highlight = {
            Enabled = true,
            FillColor = Color3.fromRGB(255, 0, 0),
            OutlineColor = Color3.fromRGB(255, 255, 255),
            FillTransparency = 0.5,
            OutlineTransparency = 0,
            PulseEffect = false,
            PulseSpeed = 1
        }
    },
    Strafe = {
        Enabled = false,
        Speed = 4,
        Height = 0,
        Distance = 6,
        Visualize = true,
        VisualizerColor = Color3.fromRGB(0, 170, 255),
        Direction = "Clockwise" -- "Clockwise" or "Counter-Clockwise"
    },
    KillAura = {
        Enabled = false,
        Mode = "Target", -- "Target" or "Always"
        Range = 500,
        LastShot = 0
    }
}

-- Create FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2
FOVCircle.NumSides = 36
FOVCircle.Radius = TargetAim.FOV.Radius
FOVCircle.Filled = TargetAim.FOV.Filled
FOVCircle.Visible = TargetAim.FOV.Visible and TargetAim.Enabled
FOVCircle.Color = TargetAim.FOV.Color
FOVCircle.Transparency = TargetAim.FOV.Transparency

-- Create highlight for target visualization
local TargetHighlight = Instance.new("Highlight")
TargetHighlight.FillColor = TargetAim.Visualization.Highlight.FillColor
TargetHighlight.OutlineColor = TargetAim.Visualization.Highlight.OutlineColor
TargetHighlight.FillTransparency = TargetAim.Visualization.Highlight.FillTransparency
TargetHighlight.OutlineTransparency = TargetAim.Visualization.Highlight.OutlineTransparency
TargetHighlight.Enabled = false
TargetHighlight.Parent = game.CoreGui

-- Create strafe visualizer as a thin line ring
local StrafeVisualizer = {}
local numSegments = 36 -- Number of line segments in the ring
for i = 1, numSegments do
    local line = Instance.new("Part")
    line.Name = "StrafeVisualizerLine_" .. i
    line.Anchored = true
    line.CanCollide = false
    line.Material = Enum.Material.Neon
    line.Color = TargetAim.Strafe.VisualizerColor
    line.Transparency = 0.3
    line.Parent = workspace
    table.insert(StrafeVisualizer, line)
end

-- Helper Functions
local function IsPlayerKnocked(character)
    -- Implement your knocked detection logic here
    -- Example: return character:FindFirstChild("Knocked") ~= nil
    return false
end

-- Find the closest player within FOV for initial locking
local function GetClosestPlayerInFOV()
    -- Check if Target Aim is enabled first
    if not TargetAim.Enabled then
        return nil, nil
    end
    
    local ClosestDistance = math.huge
    local ClosestPlayer = nil
    local ClosestPart = nil
    local MousePosition = UserInputService:GetMouseLocation()
    
    -- Hit chance check
    if TargetAim.HitChance < 100 and math.random(1, 100) > TargetAim.HitChance then
        return nil, nil
    end
    
    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character then
            local Character = Player.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")
            
            if Humanoid and Humanoid.Health > 0 and not IsPlayerKnocked(Character) then
                local HitPart = Character:FindFirstChild(TargetAim.SelectedPart)
                if HitPart then
                    local ScreenPosition, Visible = Camera:WorldToScreenPoint(HitPart.Position)
                    if Visible then
                        local Distance = (MousePosition - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
                        if Distance <= TargetAim.FOV.Radius and Distance < ClosestDistance then
                            ClosestDistance = Distance
                            ClosestPlayer = Player
                            ClosestPart = HitPart
                        end
                    end
                end
            end
        end
    end
    
    return ClosestPlayer, ClosestPart
end

-- Get the best aim part for the locked target
local function GetBestPartForTarget(player)
    -- Check if Target Aim is enabled first
    if not TargetAim.Enabled then
        return nil
    end
    
    if not player or not player.Character then return nil end
    
    local Character = player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    
    if not Humanoid or Humanoid.Health <= 0 or IsPlayerKnocked(Character) then
        return nil
    end
    
    local HitPart = Character:FindFirstChild(TargetAim.SelectedPart)
    if HitPart then
        return HitPart
    end
    
    return nil
end

-- Apply prediction to target position
local function GetPredictedPosition(part)
    if not part or not part.Parent or not part.Parent:FindFirstChildOfClass("Humanoid") then
        return part.Position
    end
    
    local velocity = part.Velocity
    local position = part.Position
    
    if TargetAim.Prediction.Enabled then
        position = position + (velocity * TargetAim.Prediction.Strength)
    end
    
    return position
end

-- Lock onto a target
local function LockTarget()
    -- Check if Target Aim is enabled first
    if not TargetAim.Enabled then
        return
    end
    
    local target, part = GetClosestPlayerInFOV()
    if target then
        TargetAim.LockedTarget = target
        TargetAim.TargetPart = part
        
        -- Apply highlight visualization
        if TargetAim.Visualization.Highlight.Enabled then
            TargetHighlight.Adornee = target.Character
            TargetHighlight.Enabled = true
        end
    end
end

-- Unlock target
local function UnlockTarget()
    if TargetAim.LockedTarget then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            -- Optional: Reset velocity to stop any momentum
            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end
        
        TargetAim.LockedTarget = nil
        TargetAim.TargetPart = nil
        
        -- Remove highlight
        TargetHighlight.Adornee = nil
        TargetHighlight.Enabled = false
    end
end

-- Check functions for target validation
local function isPlayerKnocked(player)
    if not player or not player.Character then return true end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return true end
    
    -- Check if player is knocked (customize this based on the game)
    if humanoid.PlatformStand or humanoid:GetState() == Enum.HumanoidStateType.Physics then
        return true
    end
    
    return false
end

local function isPlayerDead(player)
    if not player or not player.Character then return true end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return true end
    
    return humanoid.Health <= 0
end

local function isPlayerVisible(player)
    if not player or not player.Character then return false end
    local character = player.Character
    local targetPart = character:FindFirstChild(TargetAim.SelectedPart)
    if not targetPart then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local rayResult = workspace:Raycast(origin, direction * 1000, rayParams)
    if not rayResult then return true end
    
    return rayResult.Instance:IsDescendantOf(character)
end

-- Function to get the closest player for kill aura
local function GetClosestPlayer()
    local ClosestPlayer = nil
    local ShortestDistance = TargetAim.KillAura.Range
    
    for _, target in pairs(Players:GetPlayers()) do
        if target ~= LocalPlayer and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (target.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < ShortestDistance then
                ClosestPlayer = target
                ShortestDistance = distance
            end
        end
    end
    
    return ClosestPlayer
end

-- Function to shoot at a target
local function ShootRemote(tool, enemy)
    if enemy and enemy.Character and enemy.Character:FindFirstChild("Head") then
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        ReplicatedStorage.MainEvent:FireServer(
            "ShootGun",
            tool:FindFirstChild("Handle"),
            tool:FindFirstChild("Handle").CFrame.Position, 
            enemy.Character.HumanoidRootPart.Position,
            enemy.Character.Head,
            Vector3.new(0, 0, -1)
        )
    end
end

-- Kill Aura function
local function KillAura()
    if not TargetAim.KillAura.Enabled then return end
    
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if not tool then return end
    
    if TargetAim.KillAura.Mode == "Target" then
        -- Only target the locked player
        if TargetAim.LockedTarget then
            ShootRemote(tool, TargetAim.LockedTarget)
        end
    else -- "Always" mode
        -- Target the closest player
        local closestPlayer = GetClosestPlayer()
        if closestPlayer then
            ShootRemote(tool, closestPlayer)
        end
    end
end

-- Pulse effect variables for highlight
local currentPulseTransparency = 0.5
local highlightPulseDirection = 1

-- Strafe angle for target strafe
local strafeAngle = 0

-- Update FOV Circle position and target visualization
RunService.RenderStepped:Connect(function()
    -- Update Target Aim FOV Circle
    if FOVCircle ~= nil then
        FOVCircle.Position = UserInputService:GetMouseLocation()
        FOVCircle.Visible = TargetAim.FOV.Visible and TargetAim.Enabled
        FOVCircle.Radius = TargetAim.FOV.Radius
    end
    
    -- Update target part if we have a locked target
    if TargetAim.Enabled and TargetAim.LockedTarget then
        -- Check target validity based on settings
        if (TargetAim.Checks and TargetAim.Checks.Knocked and isPlayerKnocked(TargetAim.LockedTarget)) or
           (TargetAim.Checks and TargetAim.Checks.Dead and isPlayerDead(TargetAim.LockedTarget)) or
           (TargetAim.Checks and TargetAim.Checks.Visible and not isPlayerVisible(TargetAim.LockedTarget)) then
            UnlockTarget()
            return
        end
        
        TargetAim.TargetPart = GetBestPartForTarget(TargetAim.LockedTarget)
        
        -- If target becomes invalid, unlock
        if not TargetAim.TargetPart then
            UnlockTarget()
        else
            -- Handle highlight pulse effect
            if TargetAim.Visualization.Highlight.PulseEffect and TargetHighlight.Enabled then
                local pulseAmount = TargetAim.Visualization.Highlight.PulseSpeed * 0.02
                currentPulseTransparency = currentPulseTransparency + (highlightPulseDirection * pulseAmount)
                
                if currentPulseTransparency >= 0.9 then
                    currentPulseTransparency = 0.9
                    highlightPulseDirection = -1
                elseif currentPulseTransparency <= 0.1 then
                    currentPulseTransparency = 0.1
                    highlightPulseDirection = 1
                end
                
                TargetHighlight.FillTransparency = currentPulseTransparency
            else
                TargetHighlight.FillTransparency = TargetAim.Visualization.Highlight.FillTransparency
            end
        end
    elseif not TargetAim.Enabled and TargetAim.LockedTarget then
        -- If target aim is disabled but we still have a target, unlock it
        UnlockTarget()
    end
end)

-- Target strafe implementation
RunService.Heartbeat:Connect(function(deltaTime)
    if TargetAim.Enabled and TargetAim.LockedTarget and TargetAim.TargetPart and TargetAim.Strafe.Enabled then
        local character = LocalPlayer.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local targetRootPart = TargetAim.LockedTarget.Character:FindFirstChild("HumanoidRootPart")
        
        if rootPart and targetRootPart then
            -- Update strafe angle
            local angleChange = TargetAim.Strafe.Speed * deltaTime
            if TargetAim.Strafe.Direction == "Clockwise" then
                strafeAngle = strafeAngle + angleChange
            else
                strafeAngle = strafeAngle - angleChange
            end
            
            -- Calculate strafe position
            local targetPos = targetRootPart.Position
            local distance = TargetAim.Strafe.Distance
            local height = TargetAim.Strafe.Height
            
            local strafeX = targetPos.X + (math.cos(strafeAngle) * distance)
            local strafeZ = targetPos.Z + (math.sin(strafeAngle) * distance)
            local strafeY = targetPos.Y + height
            
            local strafePos = Vector3.new(strafeX, strafeY, strafeZ)
            
            -- Move character to strafe position
            rootPart.CFrame = CFrame.new(strafePos, targetPos)
            
            -- Update strafe visualizer ring as thin lines
            if TargetAim.Strafe.Visualize then
                for i, line in ipairs(StrafeVisualizer) do
                    local angle1 = ((i - 1) / numSegments) * (2 * math.pi)
                    local angle2 = (i / numSegments) * (2 * math.pi)
                    
                    local point1 = Vector3.new(
                        targetPos.X + (math.cos(angle1) * distance),
                        targetPos.Y + height,
                        targetPos.Z + (math.sin(angle1) * distance)
                    )
                    
                    local point2 = Vector3.new(
                        targetPos.X + (math.cos(angle2) * distance),
                        targetPos.Y + height,
                        targetPos.Z + (math.sin(angle2) * distance)
                    )
                    
                    -- Calculate direction and length for the line segment
                    local direction = (point2 - point1).Unit
                    local length = (point2 - point1).Magnitude
                    
                    -- Position the line segment at the midpoint between the two points
                    local midpoint = point1 + direction * (length / 2)
                    
                    -- Create a thin line by setting appropriate size and orientation
                    line.Size = Vector3.new(0.05, 0.05, length)
                    line.CFrame = CFrame.new(midpoint, midpoint + direction)
                    line.Color = TargetAim.Strafe.VisualizerColor
                    line.Transparency = 0.3
                end
            end
        end
    else
        -- Hide strafe visualizer when not strafing
        for _, line in ipairs(StrafeVisualizer) do
            line.Transparency = 1
        end
    end
    
    -- Execute Kill Aura
    if TargetAim.KillAura.Enabled then
        KillAura()
    end
end)

-- Hook mouse methods for target aim
local success, grm = pcall(getrawmetatable, game)
if success and grm and grm.__index and setreadonly then
    local index = grm.__index
    setreadonly(grm, false)
    
    grm.__index = function(self, Index)
        if not checkcaller() and self == Mouse then
            if Index == "Hit" or Index == "Target" then

                if TargetAim.Enabled and TargetAim.TargetPart then
                    local predictedPosition = GetPredictedPosition(TargetAim.TargetPart)
                    return Index == "Hit" and CFrame.new(predictedPosition) or TargetAim.TargetPart.Parent
                end
            end
        end
        return index(self, Index)
    end
    
    setreadonly(grm, true)
end

-- Target Aim Section in GUI
-- Target Aim Section in GUI
target_aim_rage:toggle({name = "Enabled", flag = "rage_target_aim_enabled", default = false, callback = function(bool)
    TargetAim.Enabled = bool
    
    -- If disabled, make sure to unlock any current target
    if not bool and TargetAim.LockedTarget then
        UnlockTarget()
    end
end})

-- Set up the lock key with direct toggle functionality
target_aim_rage:keybind({name = "Lock Key", flag = "rage_target_aim_lock_key", callback = function(key)
    -- Only process if Target Aim is enabled
    if library.flags.rage_target_aim_enabled then
        -- Toggle between locking and unlocking
        if TargetAim.LockedTarget then
            UnlockTarget()
        else
            LockTarget()
        end
    end
end})

target_aim_rage:slider({name = "Hit Chance", flag = "rage_target_aim_hit_chance", min = 0, max = 100, default = 100, suffix = "%", callback = function(value)
    TargetAim.HitChance = value
end})

-- Target checks dropdown
target_aim_rage:dropdown({
    name = "Target Checks",
    flag = "rage_target_aim_checks",
    items = {"Dead", "Knocked", "Visible"},
    default = {""},
    multi = true,
    callback = function(selected)
        TargetAim.Checks = {
            Dead = table.find(selected, "Dead") ~= nil,
            Knocked = table.find(selected, "Knocked") ~= nil,
            Visible = table.find(selected, "Visible") ~= nil
        }
    end
})

-- Target part dropdown
target_aim_rage:dropdown({
    name = "Target Part", 
    flag = "rage_target_aim_part", 
    items = {"Head", "HumanoidRootPart"}, 
    default = "Head", 
    callback = function(part)
        TargetAim.SelectedPart = part
    end
})

-- Prediction settings
target_aim_rage:toggle({name = "Prediction", flag = "rage_target_aim_prediction", default = true, callback = function(bool)
    TargetAim.Prediction.Enabled = bool
end})

target_aim_rage:slider({name = "Prediction Strength", flag = "rage_target_aim_prediction_strength", min = 0.05, max = 0.5, default = 0.165, interval = 0.005, suffix = "s", callback = function(value)
    TargetAim.Prediction.Strength = value
end})

-- Kill Aura settings
target_aim_rage:toggle({name = "Kill Aura", flag = "rage_kill_aura_enabled", default = false, callback = function(bool)
    TargetAim.KillAura.Enabled = bool
end})

target_aim_rage:dropdown({
    name = "Kill Aura Mode",
    flag = "rage_kill_aura_mode",
    items = {"Target", "Always"},
    default = "Target",
    callback = function(mode)
        TargetAim.KillAura.Mode = mode
    end
})

target_aim_rage:slider({name = "Kill Aura Range", flag = "rage_kill_aura_range", min = 50, max = 1000, default = 500, suffix = "m", callback = function(value)
    TargetAim.KillAura.Range = value
end})

-- Initialize Traced table for rapid fire functionality
if not _G.Traced then
    _G.Traced = {
        RapidFire = false
    }
end

-- Rapid Fire Settings
target_aim_rage:toggle({name = "Rapid Fire", flag = "rage_rapidfire_enabled", default = false, callback = function(bool)
    _G.Traced.RapidFire = bool
end})

target_aim_rage:slider({name = "Fire Rate", flag = "rage_rapidfire_rate", min = 0.00000000000000000001, max = 0.1, default = 0.00000000000000000001, interval = 0.001, callback = function(value)
    _G.RapidFireRate = value
end})

target_aim_rage:toggle({name = "Work with Kill Aura", flag = "rage_rapidfire_killaura", default = true, callback = function(bool)
    _G.RapidFireWithKillAura = bool
end})

-- FOV Settings
local fov_section = rage_tab:section({name = "FOV Settings", side = "left"})
fov_section:toggle({name = "Show FOV", flag = "rage_target_aim_show_fov", default = true, callback = function(bool)
    TargetAim.FOV.Visible = bool
end})

fov_section:colorpicker({name = "FOV Color", flag = "rage_target_aim_fov_color", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    TargetAim.FOV.Color = color
    FOVCircle.Color = color
end})

fov_section:toggle({name = "Filled FOV", flag = "rage_target_aim_fov_filled", default = false, callback = function(bool)
    TargetAim.FOV.Filled = bool
    FOVCircle.Filled = bool
end})

fov_section:slider({name = "FOV Radius", flag = "rage_target_aim_fov_radius", min = 10, max = 500, default = 85, callback = function(value)
    TargetAim.FOV.Radius = value
    FOVCircle.Radius = value
end})

fov_section:slider({name = "FOV Transparency", flag = "rage_target_aim_fov_transparency", min = 0, max = 1, default = 0.5, interval = 0.05, callback = function(value)
    TargetAim.FOV.Transparency = value
    FOVCircle.Transparency = value
end})

-- Highlight Settings
local visual_section = rage_tab:section({name = "Target Visualization", side = "right"})
visual_section:toggle({name = "Highlight Enabled", flag = "rage_target_aim_highlight", default = true, callback = function(bool)
    TargetAim.Visualization.Highlight.Enabled = bool
    
    -- Update highlight if we have a target
    if TargetAim.LockedTarget then
        TargetHighlight.Enabled = bool
    end
end})

visual_section:colorpicker({name = "Highlight Fill Color", flag = "rage_target_aim_highlight_fill", default = Color3.fromRGB(255, 0, 0), callback = function(color)
    TargetAim.Visualization.Highlight.FillColor = color
    TargetHighlight.FillColor = color
end})

visual_section:colorpicker({name = "Highlight Outline Color", flag = "rage_target_aim_highlight_outline", default = Color3.fromRGB(255, 255, 255), callback = function(color)
    TargetAim.Visualization.Highlight.OutlineColor = color
    TargetHighlight.OutlineColor = color
end})

visual_section:toggle({name = "Highlight Pulse", flag = "rage_target_aim_highlight_pulse", default = false, callback = function(bool)
    TargetAim.Visualization.Highlight.PulseEffect = bool
end})

visual_section:slider({name = "Highlight Pulse Speed", flag = "rage_target_aim_highlight_pulse_speed", min = 0.1, max = 5, default = 1, interval = 0.1, callback = function(value)
    TargetAim.Visualization.Highlight.PulseSpeed = value
end})

visual_section:toggle({name = "Visualize Strafe", flag = "rage_target_strafe_visualize", default = true, callback = function(bool)
    TargetAim.Strafe.Visualize = bool
end})

visual_section:colorpicker({name = "Strafe Visualizer Color", flag = "rage_target_strafe_color", default = Color3.fromRGB(0, 170, 255), callback = function(color)
    TargetAim.Strafe.VisualizerColor = color
    StrafeVisualizer.Color = color
end})

-- Target Strafe Settings
local strafe_section = rage_tab:section({name = "Target Strafe", side = "right"})
strafe_section:toggle({name = "Enabled", flag = "rage_target_strafe_enabled", default = false, callback = function(bool)
    TargetAim.Strafe.Enabled = bool
end})

strafe_section:slider({name = "Speed", flag = "rage_target_strafe_speed", min = 1, max = 10, default = 4, callback = function(value)
    TargetAim.Strafe.Speed = value
end})

strafe_section:slider({name = "Distance", flag = "rage_target_strafe_distance", min = 2, max = 15, default = 6, callback = function(value)
    TargetAim.Strafe.Distance = value
end})

strafe_section:slider({name = "Height", flag = "rage_target_strafe_height", min = -5, max = 5, default = 0, callback = function(value)
    TargetAim.Strafe.Height = value
end})

strafe_section:dropdown({
    name = "Direction", 
    flag = "rage_target_strafe_direction", 
    items = {"Clockwise", "Counter-Clockwise"}, 
    default = "Clockwise", 
    callback = function(direction)
        TargetAim.Strafe.Direction = direction
    end
})

-- Connect to RunService to update the rapid fire functionality
local RunService = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer
local Orginal = {}

RunService.RenderStepped:Connect(function()
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("GunScript") then
        for _, connection in ipairs(getconnections(tool.Activated)) do
            local func = connection.Function
            if func then
                local funcInfo = debug.getinfo(func)
                for i = 1, funcInfo.nups do
                    local c, n = debug.getupvalue(func, i)
                    if type(c) == "number" then
                        if not Orginal[i] then
                            Orginal[i] = c
                        end
                        
                        local shouldRapidFire = _G.Traced.RapidFire
                        
                        -- Check if Kill Aura is enabled and we should use rapid fire with it
                        if _G.RapidFireWithKillAura and TargetAim.KillAura and TargetAim.KillAura.Enabled then
                            shouldRapidFire = true
                        end
                        
                        debug.setupvalue(func, i, shouldRapidFire and (_G.RapidFireRate or 0.00000000000000000001) or Orginal[i])
                    end
                end
            end
        end
    end
end)
-- Desync section for anti-aim
local desync_section = aa_tab:section({name = "Desync", side = "left"})

-- Initialize desync table
local desync = {
    enabled = false,
    old_position = nil,
    teleportPosition = nil,
    cameraPosition = nil
}

-- Create visualizer dot
local visualizer = Instance.new("BillboardGui")
visualizer.Name = "DesyncVisualizer"
visualizer.Size = UDim2.new(0, 20, 0, 20)
visualizer.AlwaysOnTop = true
visualizer.LightInfluence = 0
visualizer.Adornee = nil -- Will be set during runtime

-- Create dot
local dot = Instance.new("Frame")
dot.Name = "Dot"
dot.Size = UDim2.new(1, 0, 1, 0)
dot.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
dot.BackgroundTransparency = 0.3
dot.BorderSizePixel = 0
dot.AnchorPoint = Vector2.new(0.5, 0.5)
dot.Position = UDim2.new(0.5, 0, 0.5, 0)
-- Make the frame circular
local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(1, 0)
uiCorner.Parent = dot
dot.Parent = visualizer

-- Create a part to attach the BillboardGui to
local visualizerAnchor = Instance.new("Part")
visualizerAnchor.Name = "DesyncAnchor"
visualizerAnchor.Size = Vector3.new(0.1, 0.1, 0.1)
visualizerAnchor.Anchored = true
visualizerAnchor.CanCollide = false
visualizerAnchor.Transparency = 1
visualizerAnchor.Parent = workspace
visualizer.Adornee = visualizerAnchor
visualizer.Parent = visualizerAnchor

-- Create camera part
local cameraTarget = Instance.new("Part")
cameraTarget.Name = "CameraTarget"
cameraTarget.Size = Vector3.new(1, 1, 1)
cameraTarget.Anchored = true
cameraTarget.CanCollide = false
cameraTarget.Transparency = 1
cameraTarget.Parent = workspace

local camera = workspace.CurrentCamera
local originalCameraSubject = nil

-- Restore function for when script is turned off
local function restoreCamera()
    if originalCameraSubject then
        camera.CameraSubject = originalCameraSubject
        originalCameraSubject = nil
    end
end

-- Add desync toggle to UI
desync_section:toggle({name = "Enable Desync", flag = "desync_enabled", default = false, callback = function(bool)
    desync.enabled = bool
    dot.BackgroundTransparency = desync.enabled and 0.3 or 1
    
    if not desync.enabled then
        restoreCamera()
    end
    
    print("Desync:", desync.enabled and "Enabled" or "Disabled")
end})

-- Add keybind for quick toggle
desync_section:keybind({name = "Toggle Keybind", flag = "desync_keybind", default = Enum.KeyCode.X, callback = function()
    library.flags["desync_enabled"] = not library.flags["desync_enabled"]
    desync.enabled = library.flags["desync_enabled"]
    dot.BackgroundTransparency = desync.enabled and 0.3 or 1
    
    if not desync.enabled then
        restoreCamera()
    end
    
    print("Desync:", desync.enabled and "Enabled" or "Disabled")
end})

-- Add desync mode dropdown (added Void mode)
desync_section:dropdown({name = "Desync Mode", flag = "desync_mode", default = "Random", items = {"Random", "Void"}, callback = function(mode)
    print("Desync Mode:", mode)
end})

-- Add desync settings for Random mode
desync_section:slider({name = "Horizontal Range", flag = "desync_horizontal_range", min = 1, max = 20, default = 10, interval = 1, suffix = "studs"})
desync_section:slider({name = "Vertical Range", flag = "desync_vertical_range", min = 1, max = 10, default = 5, interval = 1, suffix = "studs"})

-- Add void mode settings
local void_section = aa_tab:section({name = "Void Settings", side = "left"})
void_section:slider({name = "X Position", flag = "void_x", min = -10000, max = 10000, default = 0, interval = 100, suffix = ""})
void_section:slider({name = "Y Position", flag = "void_y", min = -10000, max = 10000, default = 0, interval = 100, suffix = ""})
void_section:slider({name = "Z Position", flag = "void_z", min = -10000, max = 10000, default = 0, interval = 100, suffix = ""})
void_section:toggle({name = "Randomize X", flag = "void_random_x", default = false})
void_section:toggle({name = "Randomize Y", flag = "void_random_y", default = false})
void_section:toggle({name = "Randomize Z", flag = "void_random_z", default = false})
void_section:slider({name = "Random Range", flag = "void_random_range", min = 100, max = 20000, default = 1000, interval = 100, suffix = ""})

-- Add visualization settings
desync_section:colorpicker({name = "Visualizer Color", flag = "desync_color", default = Color3.fromRGB(0, 170, 255), callback = function(color)
    dot.BackgroundColor3 = color
end})

-- Add visualization style dropdown
desync_section:dropdown({name = "Visualization Style", flag = "desync_viz_style", default = "Dot", items = {"Dot", "Pulse", "Blink", "None"}, callback = function(style)
    if style == "None" then
        visualizer.Enabled = false
    else
        visualizer.Enabled = true
    end
end})

-- Start the desync loop
RunService.Heartbeat:Connect(function()
    if not desync.enabled then return end
    if not LocalPlayer or not LocalPlayer.Character then return end
    
    local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if rootPart and humanoid then
        -- Save original positions and settings
        if originalCameraSubject == nil then
            originalCameraSubject = camera.CameraSubject
        end
        
        -- Save character position
        desync.old_position = rootPart.CFrame
        desync.cameraPosition = desync.old_position
        
        -- Update camera target position
        cameraTarget.CFrame = desync.old_position
        
        -- Set camera to look at the camera target instead of the character
        camera.CameraSubject = cameraTarget
        
        -- Calculate new teleport position based on selected mode
        local mode = library.flags["desync_mode"]
        
        if mode == "Random" then
            local horizontalRange = library.flags["desync_horizontal_range"] or 10
            local verticalRange = library.flags["desync_vertical_range"] or 5
            
            desync.teleportPosition = Vector3.new(
                rootPart.Position.X + math.random(-horizontalRange, horizontalRange),
                rootPart.Position.Y + math.random(-verticalRange, verticalRange),
                rootPart.Position.Z + math.random(-horizontalRange, horizontalRange)
            )
        elseif mode == "Void" then
            local x = library.flags["void_x"] or 0
            local y = library.flags["void_y"] or 0
            local z = library.flags["void_z"] or 0
            local randomRange = library.flags["void_random_range"] or 1000
            
            -- Apply randomization if enabled
            if library.flags["void_random_x"] then
                x = x + math.random(-randomRange, randomRange)
            end
            
            if library.flags["void_random_y"] then
                y = y + math.random(-randomRange, randomRange)
            end
            
            if library.flags["void_random_z"] then
                z = z + math.random(-randomRange, randomRange)
            end
            
            desync.teleportPosition = Vector3.new(x, y, z)
        end
        
        -- Update visualizer position
        visualizerAnchor.Position = desync.teleportPosition
        
        -- Handle visualization styles
        local vizStyle = library.flags["desync_viz_style"]
        if vizStyle == "Pulse" then
            dot.BackgroundTransparency = 0.3 + (math.sin(tick() * 5) * 0.3)
            dot.Size = UDim2.new(1 + (math.sin(tick() * 5) * 0.2), 0, 1 + (math.sin(tick() * 5) * 0.2), 0)
        elseif vizStyle == "Blink" then
            dot.BackgroundTransparency = math.floor(tick() * 2) % 2 == 0 and 0.3 or 0.9
        elseif vizStyle == "Dot" then
            dot.BackgroundTransparency = 0.3
            dot.Size = UDim2.new(1, 0, 1, 0)
        end
        
        -- Teleport the character
        rootPart.CFrame = CFrame.new(desync.teleportPosition)
        
        -- Wait for the next render step
        RunService.RenderStepped:Wait()
        
        -- Return the character to original position for next cycle
        rootPart.CFrame = desync.old_position
    end
end)



do -- Configs
    local configs = window:tab({name = "configs"})
    local config = configs:section({name = "Theming System", side = "right"})
    config:toggle({name = "Keybind List", flag = "keybind_list", default = false, callback = function(bool)
        window.toggle_list(bool)
    end})
    config:toggle({name = "Player List", flag = "player_list", default = false, callback = function(bool)
        window.toggle_playerlist(bool)
    end})
    config:toggle({name = "Watermark", flag = "watermark", default = false, callback = function(bool)
        window.toggle_watermark(bool)
    end})
    config:keybind({name = "UI Bind", default = Enum.KeyCode.End, callback = window.set_menu_visibility})
    config:slider({name = "Colorpicker Animation Speed", flag = 'color_picker_anim_speed', min = 0, max = 5, default = 2, interval = 0.01, suffix = ""})
    config:colorpicker({color = Color3.fromHex("#6464FF"), flag = "accent", callback = function(color)
        library:update_theme("accent", color)
    end})
    config:button({name = "Copy JobId", callback = function()
        setclipboard(game.JobId)
    end})
    config:button({name = "Copy GameID", callback = function()
        setclipboard(game.GameId)
    end})
    config:button({name = "Copy Join Script", callback = function()
        setclipboard('game:GetService("TeleportService"):TeleportToPlaceInstance(' .. game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)')
    end})
    config:button({name = "Rejoin", callback = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
    end})



    local configs_section = configs:section({name = "Configuration System", side = "left"})
    library.config_holder = configs_section:dropdown({name = "Configs", items = {}, flag = "config_name_list"})
    configs_section:textbox({flag = "config_name_text_box"})
    configs_section:button({name = "Create", callback = function()
        writefile(library.directory .. "/configs/" .. flags["config_name_text_box"] .. ".cfg", library:get_config())
        library:config_list_update()
    end})
    configs_section:button({name = "Delete", callback = function()
        library:panel({
            name = "Are you sure you want to delete " .. flags["config_name_list"] .. " ?",
            options = {"Yes", "No"},
            callback = function(option)
                print(option)
                if option == "Yes" then 
                    delfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg")
                    library:config_list_update()
                end 
            end
        })
    end})
    configs_section:button({name = "Load", callback = function()
        library:load_config(readfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg"))
    end})
    configs_section:button({name = "Save", callback = function()
        writefile(library.directory .. "/configs/" .. flags["config_name_text_box"] .. ".cfg", library:get_config())
        library:config_list_update()
    end})
    configs_section:button({name = "Unload Config", callback = function()
        library:load_config(old_config)
    end})
    configs_section:button({name = "Unload Menu", callback = function()
        library:unload()
    end}) library:config_list_update()
end

legit.open_tab()
